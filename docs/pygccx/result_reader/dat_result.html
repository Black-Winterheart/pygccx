<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pygccx.result_reader.dat_result API documentation</title>
<meta name="description" content="Copyright Matthias Sedlmaier 2022
This file is part of pygccx â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygccx.result_reader.dat_result</code></h1>
</header>
<section id="section-intro">
<p>Copyright Matthias Sedlmaier 2022
This file is part of pygccx.</p>
<p>pygccx is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.</p>
<p>pygccx is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with pygccx.<br>
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Copyright Matthias Sedlmaier 2022
This file is part of pygccx.

pygccx is free software: you can redistribute it 
and/or modify it under the terms of the GNU General Public License as 
published by the Free Software Foundation, either version 3 of the 
License, or (at your option) any later version.

pygccx is distributed in the hope that it will 
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pygccx.  
If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#39;&#39;&#39;

from dataclasses import dataclass, field
import csv, re
from collections import defaultdict
from typing import Iterable, Generator, Optional
from collections import namedtuple
from enum import Enum, auto

import numpy as np
import numpy.typing as npt

from pygccx.enums import EResultLocations, EDatEntities, EDatAnalysisTypes


ENTITY_2_LOCATION_MAP = {
    # Node Print entities
    EDatEntities.U : EResultLocations.NODAL,
    EDatEntities.RF : EResultLocations.NODAL,
    # El Print entities
    EDatEntities.S : EResultLocations.INT_PNT,
    EDatEntities.E : EResultLocations.INT_PNT,
    EDatEntities.ME : EResultLocations.INT_PNT,
    EDatEntities.PEEQ : EResultLocations.INT_PNT,
    EDatEntities.EVOL : EResultLocations.ELEMENT,
    EDatEntities.COORD : EResultLocations.INT_PNT,
    EDatEntities.ENER : EResultLocations.INT_PNT,
    EDatEntities.ELKE : EResultLocations.ELEMENT,
    EDatEntities.ELSE : EResultLocations.ELEMENT,
    EDatEntities.EMAS : EResultLocations.ELEMENT,
    # Contact print entities
    EDatEntities.CELS : EResultLocations.NODAL,
    EDatEntities.CSTR : EResultLocations.NODAL,
    EDatEntities.CDIS : EResultLocations.NODAL
}

@dataclass(frozen=True, slots=True)
class DatResultSet:
    &#34;&#34;&#34;
    Class representing a result set from a *.dat file.

    A result set contains the nodal, element or integration point result 
    values of an entity (i.e. U, S) for a single step time.
    &#34;&#34;&#34;
    entity:EDatEntities
    &#34;&#34;&#34;Enum of the result set entity i.e. U, S&#34;&#34;&#34;
    no_components:int
    &#34;&#34;&#34;number of components per value. I.e. for a U result set no_components == 3&#34;&#34;&#34;
    step_time:float
    &#34;&#34;&#34;Step time of this result set&#34;&#34;&#34;
    step_no:int
    &#34;&#34;&#34;Step number of this result set since the beginning of the calculation.&#34;&#34;&#34;
    step_inc_no:int
    &#34;&#34;&#34;Increment number of this result set since the beginning of the step.
    Increment number for *STATIC, mode number for *FREQUENCY, factor number for *BUCKLE&#34;&#34;&#34;
    analysis_type:EDatAnalysisTypes
    &#34;&#34;&#34;Analysis type of this result set&#34;&#34;&#34;
    set_name:str
    &#34;&#34;&#34;Name of the node- or element set.&#34;&#34;&#34;
    component_names:tuple[str,...]
    &#34;&#34;&#34;Names of the value components. I.e. for a U result set (&#39;vx&#39;, &#39;vy&#39;, &#39;vz&#39;)&#34;&#34;&#34;
    values:dict[int, npt.NDArray] = field(repr=False)
    &#34;&#34;&#34;
    Dictionary with values.\n
    key = node id, 
    if entity_location==NODAL or ELEMENT: value = vector with entity components\n 
    if entity_location==INT_PNT: value = m x n array with m = number of int.pnts. and n = number of components.
    &#34;&#34;&#34;
    entity_location:EResultLocations
    &#34;&#34;&#34;Location of the result entity. i.e. NODAL, ELEMENT, ...&#34;&#34;&#34;


    def get_values_by_ids(self, ids:Iterable[int]) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Returns the result values for the given node or element ids as a numpy array.

        if entity_location==NODAL or ELEMENT: 
            2D Array is returned.
            len axis 0: number of given ids
            len axis 1: number of components.
        if entity_location==INT_PNT:
            3D Array is returned
            len axis 0: number of given ids
            len axis 1: number of int. pnts
            len axis 2: number of components

        The order of axis 0 is the same as ids.
        If ids is a non ordered iterable (i.e. a set) the ordering is arbitrary.

        If a node id is not in values an exception is raised. 
        &#34;&#34;&#34;
        return np.array([self.values[id] for id in ids])

@dataclass(frozen=True, slots=True)  
class BuckleIncrementInfo:
    step_no:int
    &#34;&#34;&#34;Step number of this result set since the beginning of the calculation.&#34;&#34;&#34;
    step_inc_no:int
    &#34;&#34;&#34;Increment number of this result set since the beginning of the step.
    In this context step_inc_no is the buckling mode number.&#34;&#34;&#34;
    buckling_factor:float
    &#34;&#34;&#34;The buckling factor for this mode.&#34;&#34;&#34;


FreqencyInfo = namedtuple(&#39;FrequencyInfo&#39;, [&#39;eigen_value&#39;, &#39;omega_real&#39;, &#39;freq_real&#39;, &#39;omega_imag&#39;,&#39;nodal_diameter&#39;])
DofInfo = namedtuple(&#39;DofInfo&#39;, [&#39;vx&#39;, &#39;vy&#39;, &#39;vz&#39;, &#39;rx&#39;, &#39;ry&#39;, &#39;rz&#39;])
Vector = namedtuple(&#39;Vector&#39;, [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])
EigenmodeTurningDirection = namedtuple(&#39;EigenmodeTurningDirection&#39;, [&#39;nodal_diameter&#39;, &#39;direction&#39;])

@dataclass(frozen=True, slots=True)  
class FrequencyIncrementInfo:
    step_no:int
    &#34;&#34;&#34;Step number of this result set since the beginning of the calculation.&#34;&#34;&#34;
    step_inc_no:int
    &#34;&#34;&#34;Increment number of this result set since the beginning of the step.
    In this context step_inc_no is the frequency mode number.&#34;&#34;&#34;
    frequencies: FreqencyInfo
    &#34;&#34;&#34;Named tuple with eigen value, frequency, angular velocity etc for this mode.&#34;&#34;&#34;
    participation_factors: DofInfo
    &#34;&#34;&#34;Named tuple with with participation factors in vx, vy, vz, rx, ry, rz for this mode.&#34;&#34;&#34;
    effective_modal_mass: DofInfo
    &#34;&#34;&#34;Named tuple with with effective modal mass in vx, vy, vz, rx, ry, rz for this mode.&#34;&#34;&#34;
    eigenmode_turning_direction:EigenmodeTurningDirection|None


IncrementInfo = BuckleIncrementInfo|FrequencyIncrementInfo

@dataclass(frozen=True, slots=True)  
class StepInfoBase:
    step_no:int
    &#34;&#34;&#34;Step number of this result set since the beginning of the calculation.&#34;&#34;&#34;
    _increment_infos:dict[int, IncrementInfo]

    def get_increment_infos(self, *inc_no:int) -&gt; tuple[IncrementInfo|None]:
        &#34;&#34;&#34;Returns a tuple with IncrementInfos for the given increment numbers.

        Args:
            *inc_no (int): One or more increment numbers for which IncrementInfos should be returned.
                            If no inc_no is given, all increment infos are returned.

        Returns:
            tuple[IncrementInfo|None]: Tuple with IncrementInfos. Same order and length as inc_no.
            If there are no increment infos, an empty tuple is returned. 
            If an inc_no does not exist, the corresponding tuple element is None.
        &#34;&#34;&#34;

        if not inc_no: return tuple(self._increment_infos[i] for i in sorted(self._increment_infos))
        return tuple(self._increment_infos.get(i) for i in inc_no)

@dataclass(frozen=True, slots=True)  
class BuckleStepInfo(StepInfoBase):
    pass

@dataclass(frozen=True, slots=True)  
class FrequencyStepInfo(StepInfoBase):
    total_effective_mass: DofInfo
    &#34;&#34;&#34;Named tuple with with total effective mass in vx, vy, vz, rx, ry, rz. Same for all modes&#34;&#34;&#34;
    axis_reference_direction: Vector|None
    &#34;&#34;&#34;Direction vector of the cyclic symmetry axis. Only available for cycliy symmetric frequency steps &#34;&#34;&#34;

StepInfo = BuckleStepInfo|FrequencyStepInfo
@dataclass(frozen=True, slots=True)
class DatResult:
    &#34;&#34;&#34;
    Class representing the content of a *.dat file. 
    
    Don&#39;t instanciate this class directly. Use DatResult.from_file() instead.
    &#34;&#34;&#34;
    _step_infos:dict[int, StepInfo]
    &#34;&#34;&#34;Dictionary with increment infos for each step&#34;&#34;&#34;
    result_sets:tuple[DatResultSet, ...]
    &#34;&#34;&#34;Tuple with all result sets&#34;&#34;&#34;

    def get_step_info(self, step_no:int) -&gt; StepInfo|None:
        &#34;&#34;&#34;Returns the StepInfo for the given step_no.
        If step_no has no StepInfo, None is returned.

        Args:
            step_no (int): Step number for which StepInfos should be returned.

        Returns:
            StepInfo|None: StepInfo for step_no or None
        &#34;&#34;&#34;
        return self._step_infos.get(step_no)

    def get_available_times(self) -&gt; tuple[float, ...]:
        &#34;&#34;&#34;Returns a sorted tuple with all available times.&#34;&#34;&#34;
        return tuple(sorted({rs.step_time for rs in self.result_sets}))
    
    def get_result_sets_by(self,*,
                            entity:Optional[EDatEntities]=None,
                            step_no:Optional[int]=None,
                            step_inc_no:Optional[int]=None,
                            step_time:Optional[float]=None,
                            analysis_type:Optional[EDatAnalysisTypes]=None,
                            set_name:Optional[str]=None
                            ) -&gt; tuple[DatResultSet,...]:
        
        &#34;&#34;&#34;Returns a tuple with DatResultSets filtered by the given values.
        The kwarg step_time is applied at last, if given. 
        The results with the closest time to given step_time will be returned.

        Returns:
            tuple[DatResultsSet,...]: Filtered result sets
        &#34;&#34;&#34;

        rs = self.result_sets

        if entity is not None: rs = [r for r in rs if r.entity==entity]
        if step_no is not None: rs = [r for r in rs if r.step_no==step_no]
        if step_inc_no is not None: rs = [r for r in rs if r.step_inc_no==step_inc_no]
        if analysis_type is not None: rs = [r for r in rs if r.analysis_type==analysis_type]
        if set_name is not None: rs = [r for r in rs if r.set_name==set_name]
        if step_time is not None:
            available_times = {rs.step_time for rs in self.result_sets}
            nearest_time = min(available_times, key=lambda x:abs(x - step_time)) 
            rs = [r for r in rs if r.step_time==nearest_time]

        return tuple(rs)

    @classmethod
    def from_file(cls, filename:str) -&gt; &#39;DatResult&#39;:
        &#34;&#34;&#34;
        Creates a FrdResult from the given filename and returns it.

        IMPORTANT:
        Total result sets (with parameter TOTALS set in *NODE PRINT, *EL PRINT, etc)
        are not processed. These values can be obtained with simple numpy operations
        like np.sum() from the same result, if TOTALS is omitted.

        Args:
            filename (str): Path to ascii *.dat file

        Returns:
            DatResult
        &#34;&#34;&#34;

        with open(filename) as f:
            csv_reader = csv.reader(f, delimiter=&#39; &#39;, skipinitialspace=True)
            stream = (line for line in csv_reader if line) # filter out blank lines
            return DatReader()(stream)
     
class DatReader:
        &#34;&#34;&#34;State machine to parse a stream generator of a dat file&#34;&#34;&#34;
        class States(Enum):
            NONE = auto()
            RESULT_SET_OPEN = auto()
            BUCKLING_INFO_OPEN = auto()
            FREQUENCY_INFO_OPEN = auto()

        dat_entities_str = tuple({x.value for x in EDatEntities})

        def __init__(self):
            # Internal state variables
            self.state = DatReader.States.NONE
            self.result_sets:list[DatResultSet] = []
            self.entity_name, self.step_time, self.set_name = &#39;&#39;, 0., &#39;&#39;
            self.entity_type, self.entity_loc = EDatEntities.U, EResultLocations.NODAL
            self.component_names:tuple[str,...] = ()
            self.value_dict = defaultdict(list)  
            self.step_no = 0
            self.step_inc = 0
            self.step_type = EDatAnalysisTypes.STATIC
            self.result_sets:list[DatResultSet] = []
            self.step_infos = {}
            self.total_inc_no = 0

        def __call__(self, stream:Generator[list[str], None, None]) -&gt; DatResult:
            &#34;&#34;&#34;Parses the given stream generatur of a dat file and returns a DatResult

            Args:
                stream (Generator[list[str], None, None]): stream generator yielding lines of dat file.
                                                        Each line was split by blanks and empty lines are skipped

            Raises:
                DatFileVersionError: Raises if no &#34;S T E P&#34; word was found in file. This usually indicates that the file was written by ccx &lt; 2.22

            Returns:
                DatResult: DatResult construkted from stream
            &#34;&#34;&#34;

            line = next(stream, None)
            has_step_word = False # Flag to check if &#34;STEP&#34; is present in file.
                                  # This indicates, that the file was written by ccx &gt;= 2.22
            while line:
                # Parsing for new state
                # ---------------------------------------------------------
                if self.state == DatReader.States.NONE:
                    line_join = &#39;&#39;.join(line)

                    if line_join[0] == &#39;S&#39; and line_join.startswith(&#39;STEP&#39;):
                        # checks for beginning of a new step
                        has_step_word = True
                        self.step_no = int(line[-1])
                        self.step_inc = 0
                        self.step_type = EDatAnalysisTypes.STATIC

                    elif line_join[0] == &#39;E&#39; and line_join.startswith(&#39;EIGENVALUENUMBER&#39;):
                        # chekcs for increment number in frequency or buckle step
                        self.step_inc = int(line[-1])
                        self.total_inc_no += 1

                    elif line_join[0] == &#39;I&#39; and line_join.startswith(&#39;INCREMENT&#39;):
                        # check for increment bumber in static step
                        self.step_inc = int(line[-1])
                        self.total_inc_no += 1

                    elif line_join[0] == &#39;E&#39; and line_join.startswith(&#39;EIGENVALUEOUTPUT&#39;):
                        # checks if step a frequency step
                        self.state = DatReader.States.FREQUENCY_INFO_OPEN
                        
                    elif line_join[0] == &#39;B&#39; and line_join.startswith(&#39;BUCKLINGFACTOROUTPUT&#39;):
                        # chekcs if step is a buckling step
                        self.state = DatReader.States.BUCKLING_INFO_OPEN
                        
                    elif &#39; &#39;.join(line).startswith(DatReader.dat_entities_str):
                        # if this line was reached without a &#34;STEP&#34; before, this file was written by ccx &lt; 2.22
                        if not has_step_word:
                            raise DatFileVersionError(&#34;This *.dat file was written by a ccx version &lt; 2.22.&#34;)
                        # cheks if a result set starts
                        try: # for safety. Should never raise. If so, line[0] doesn&#39;t initiate a result set
                            self._start_result_set(line)
                            self.state = DatReader.States.RESULT_SET_OPEN
                        except: pass

                # Handling new state
                # ---------------------------------------------------------       
                elif self.state == DatReader.States.RESULT_SET_OPEN: 
                    line = self._handle_result_set_open(line, stream)
                    self.state = DatReader.States.NONE
                    continue

                elif self.state == DatReader.States.BUCKLING_INFO_OPEN:
                    line = self._handle_buckling_info_open(line, stream)
                    self.state = DatReader.States.NONE
                    continue

                elif self.state == DatReader.States.FREQUENCY_INFO_OPEN:
                    line = self._handle_frequency_info_open(line, stream)
                    self.state = DatReader.States.NONE
                    continue

                line = next(stream, None)

            return DatResult(self.step_infos, tuple(self.result_sets))

        def _handle_result_set_open(self, line:list[str], stream:Generator[list[str], None, None]):

            while line:
                try:
                    id, data = _parse_data_line(line, self.entity_loc) # raises if line[0] is not numeric
                    self.value_dict[id].append(data)
                except: 
                    break
                line = next(stream, None)
            self._finish_result_set()
            return line
        
        def _handle_buckling_info_open(self, line:list[str], stream:Generator[list[str], None, None]):
            self.step_type = EDatAnalysisTypes.BUCKLE
            step_info = BuckleStepInfo(self.step_no, {})
            self.step_infos[self. step_no] = step_info

            while not _isnumeric(line[0]):
                line = next(stream, None)
            while line:
                try:
                    mode_no, factor = int(line[0]), float(line[1]) 
                    step_info._increment_infos[mode_no] = BuckleIncrementInfo(self.step_no, mode_no, factor)
                except:
                    break
                line = next(stream, None)
            return line

        def _handle_frequency_info_open(self, line:list[str], stream:Generator[list[str], None, None]):
            self.step_type = EDatAnalysisTypes.FREQUENCY


            freqs, part_facs, eff_mass, eigen_turn_dir = {},{},{},{}
            is_cyclic = False
            axis_reference_direction, total_eff_mass = None, None
            while not _isnumeric(line[0]):
                if line[0] == &#39;DIAMETER&#39;: is_cyclic = True
                line = next(stream, None)
            while line:
                try:
                    if is_cyclic:
                        diameter, mode_no, ev, w_real, f_real, w_imag = [float(x) for x in line]
                        diameter = int(diameter)
                    else:
                        mode_no, ev, w_real, f_real, w_imag = [float(x) for x in line]
                        diameter = None
                    freqs[int(mode_no)] = FreqencyInfo(ev, w_real, f_real, w_imag, diameter)
                except:
                    break
                line = next(stream, None)

            while line:
                line_join = &#39;&#39;.join(line)
                if line[0] == &#39;TOTAL&#39;: 
                    line = next(stream, None)
                elif line_join == &#39;PARTICIPATIONFACTORS&#39; or line_join == &#39;EFFECTIVEMODALMASS&#39;:
                    while not _isnumeric(line[0]):
                        line = next(stream, None)
                    while line:
                        try:
                            mode_no, vx, vy, vz, rx, ry, rz = [float(x) for x in line]
                            d = DofInfo(vx, vy, vz, rx, ry, rz)
                            if line_join[0] == &#39;P&#39;: part_facs[int(mode_no)] = d          
                            if line_join[0] == &#39;E&#39;: eff_mass[int(mode_no)] = d             
                        except:
                            break
                        line = next(stream, None)
                elif line_join == &#39;TOTALEFFECTIVEMASS&#39;:
                    while not _isnumeric(line[0]):
                        line = next(stream, None)  
                    while line:
                        try:
                            vx, vy, vz, rx, ry, rz = [float(x) for x in line]
                            total_eff_mass = DofInfo(vx, vy, vz, rx, ry, rz)                 
                        except:
                            break
                        line = next(stream, None)
                elif line_join == &#39;EIGENMODETURNINGDIRECTION&#39;:
                    while not _isnumeric(line[0]):
                        if &#39;&#39;.join(line).startswith(&#39;Axisreferencedirection&#39;):
                            axis_reference_direction = Vector(*[float(x) for x in line[-3:]])
                        line = next(stream, None) 
                    while line:
                        try:
                            node_dia, mode_no, dir = int(line[0]), int(line[1]), line[2]
                            eigen_turn_dir[mode_no] = EigenmodeTurningDirection(node_dia, dir)
                            total_eff_mass = DofInfo(vx, vy, vz, rx, ry, rz)                 
                        except:
                            break
                        line = next(stream, None)
                else:
                    break

            increment_infos = {mode_no:FrequencyIncrementInfo(self.step_no, mode_no, 
                                                        freqs[mode_no], part_facs[mode_no], 
                                                        eff_mass[mode_no], eigen_turn_dir.get(mode_no)) 
                                                        for mode_no in freqs}

            self.step_infos[self. step_no] = FrequencyStepInfo(self.step_no, increment_infos, 
                                                      total_eff_mass,
                                                      axis_reference_direction)

            return line

        def _start_result_set(self, line:list[str]):

            self.entity_name, self.set_name, self.step_time = _parse_header_line(line)
            self.component_names = _parse_header_components(line)
            self.entity_type = EDatEntities(self.entity_name)
            self.entity_loc = ENTITY_2_LOCATION_MAP[self.entity_type]                        
            self.value_dict = defaultdict(list)            

        def _finish_result_set(self) -&gt; DatResultSet:

            values_arr = _value_dict_to_value(self.value_dict, self.entity_loc)
            no_comp = _get_no_comp(values_arr)
            self.result_sets.append(DatResultSet(self.entity_type, no_comp, self.step_time, 
                                                self.step_no, self.step_inc, 
                                                self.step_type, self.set_name, 
                                                self.component_names[-no_comp:],values_arr, 
                                                self.entity_loc))  

def _parse_header_line(line:list[str]) -&gt; tuple[str, str, float]:

    if line[0] == &#39;total&#39;: raise ValueError()
    
    # step time
    step_time = float(line[-1])

    i_and = line.index(&#39;and&#39;) # raises exception if &#39;and&#39; is not present in header

    try:
        i_set = line.index(&#39;set&#39;) # raises exception if &#39;set&#39; is not present in header
        # if a set is defined, its name is located between the words &#39;set&#39; and &#39;and&#39;
        set_name = &#39; &#39;.join(line[i_set + 1 : i_and])
    except:
        set_name = &#39;&#39;

    # result name
    # result name ends at the first occurence of &#39;(&#39; or the word &#39;for&#39;
    entity_name = &#39;&#39;
    for i, col in enumerate(line):
        if col.startswith(&#39;(&#39;) or col == &#39;for&#39;:
            entity_name = &#39; &#39;.join(line[:i])
            break

    return entity_name, set_name, step_time
    
def _parse_header_components(line:list[str]) -&gt; tuple[str,...]:

    lin = &#39; &#39;.join(line)
    comp = re.findall(r&#39;\((.*?)\)&#39;, lin)
    comp = &#39;,&#39;.join(comp)
    comp = [c.strip() for c in comp.split(&#39;,&#39;)]
    # comp = [c for c in comp if c not in {&#39;elem&#39;, &#39;integ.pnt.&#39;, &#39;element&#39;}]

    return tuple(comp)

def _parse_data_line(line:list[str], entity_loc:EResultLocations):

    id = int(line[0]) # throws exception if not convertable
    # delete non numeric elements in line. i.e. the &#39;L&#39; at the end
    line = [s for s in line if _isnumeric(s)]
    if entity_loc == EResultLocations.INT_PNT:
        return id, np.array(line[2:], dtype=float)
    return id, np.array(line[1:], dtype=float)
    
def _value_dict_to_value(value_dict:dict[int, list[npt.NDArray]], entity_loc:EResultLocations) -&gt; dict[int, npt.NDArray]:

    if entity_loc == EResultLocations.INT_PNT:
        return {id : np.array(l) for id, l in value_dict.items()}
    return {id : l[0] for id, l in value_dict.items()}

def _get_no_comp(value_dict:dict[int, npt.NDArray]) -&gt; int:

    # get arbitrary array:
    a = next(iter(value_dict.values()))
    if len(a.shape) == 1: return a.shape[0] 
    return a.shape[1]

def _isnumeric(x) -&gt; bool:
    try:
        float(x)
        return True
    except:
        return False

class DatFileVersionError(Exception):
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygccx.result_reader.dat_result.BuckleIncrementInfo"><code class="flex name class">
<span>class <span class="ident">BuckleIncrementInfo</span></span>
<span>(</span><span>step_no:Â int, step_inc_no:Â int, buckling_factor:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>BuckleIncrementInfo(step_no: int, step_inc_no: int, buckling_factor: float)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, slots=True)  
class BuckleIncrementInfo:
    step_no:int
    &#34;&#34;&#34;Step number of this result set since the beginning of the calculation.&#34;&#34;&#34;
    step_inc_no:int
    &#34;&#34;&#34;Increment number of this result set since the beginning of the step.
    In this context step_inc_no is the buckling mode number.&#34;&#34;&#34;
    buckling_factor:float
    &#34;&#34;&#34;The buckling factor for this mode.&#34;&#34;&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.BuckleIncrementInfo.buckling_factor"><code class="name">var <span class="ident">buckling_factor</span> :Â float</code></dt>
<dd>
<div class="desc"><p>The buckling factor for this mode.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.BuckleIncrementInfo.step_inc_no"><code class="name">var <span class="ident">step_inc_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Increment number of this result set since the beginning of the step.
In this context step_inc_no is the buckling mode number.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.BuckleIncrementInfo.step_no"><code class="name">var <span class="ident">step_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Step number of this result set since the beginning of the calculation.</p></div>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.BuckleStepInfo"><code class="flex name class">
<span>class <span class="ident">BuckleStepInfo</span></span>
<span>(</span><span>step_no:Â int, _increment_infos:Â dict[int,Â <a title="pygccx.result_reader.dat_result.BuckleIncrementInfo" href="#pygccx.result_reader.dat_result.BuckleIncrementInfo">BuckleIncrementInfo</a>Â |Â <a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo">FrequencyIncrementInfo</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>BuckleStepInfo(step_no: int, _increment_infos: dict[int, pygccx.result_reader.dat_result.BuckleIncrementInfo | pygccx.result_reader.dat_result.FrequencyIncrementInfo])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, slots=True)  
class BuckleStepInfo(StepInfoBase):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pygccx.result_reader.dat_result.StepInfoBase" href="#pygccx.result_reader.dat_result.StepInfoBase">StepInfoBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.BuckleStepInfo.step_no"><code class="name">var <span class="ident">step_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pygccx.result_reader.dat_result.StepInfoBase" href="#pygccx.result_reader.dat_result.StepInfoBase">StepInfoBase</a></b></code>:
<ul class="hlist">
<li><code><a title="pygccx.result_reader.dat_result.StepInfoBase.get_increment_infos" href="#pygccx.result_reader.dat_result.StepInfoBase.get_increment_infos">get_increment_infos</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pygccx.result_reader.dat_result.DatFileVersionError"><code class="flex name class">
<span>class <span class="ident">DatFileVersionError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatFileVersionError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pygccx.result_reader.dat_result.DatReader"><code class="flex name class">
<span>class <span class="ident">DatReader</span></span>
</code></dt>
<dd>
<div class="desc"><p>State machine to parse a stream generator of a dat file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatReader:
        &#34;&#34;&#34;State machine to parse a stream generator of a dat file&#34;&#34;&#34;
        class States(Enum):
            NONE = auto()
            RESULT_SET_OPEN = auto()
            BUCKLING_INFO_OPEN = auto()
            FREQUENCY_INFO_OPEN = auto()

        dat_entities_str = tuple({x.value for x in EDatEntities})

        def __init__(self):
            # Internal state variables
            self.state = DatReader.States.NONE
            self.result_sets:list[DatResultSet] = []
            self.entity_name, self.step_time, self.set_name = &#39;&#39;, 0., &#39;&#39;
            self.entity_type, self.entity_loc = EDatEntities.U, EResultLocations.NODAL
            self.component_names:tuple[str,...] = ()
            self.value_dict = defaultdict(list)  
            self.step_no = 0
            self.step_inc = 0
            self.step_type = EDatAnalysisTypes.STATIC
            self.result_sets:list[DatResultSet] = []
            self.step_infos = {}
            self.total_inc_no = 0

        def __call__(self, stream:Generator[list[str], None, None]) -&gt; DatResult:
            &#34;&#34;&#34;Parses the given stream generatur of a dat file and returns a DatResult

            Args:
                stream (Generator[list[str], None, None]): stream generator yielding lines of dat file.
                                                        Each line was split by blanks and empty lines are skipped

            Raises:
                DatFileVersionError: Raises if no &#34;S T E P&#34; word was found in file. This usually indicates that the file was written by ccx &lt; 2.22

            Returns:
                DatResult: DatResult construkted from stream
            &#34;&#34;&#34;

            line = next(stream, None)
            has_step_word = False # Flag to check if &#34;STEP&#34; is present in file.
                                  # This indicates, that the file was written by ccx &gt;= 2.22
            while line:
                # Parsing for new state
                # ---------------------------------------------------------
                if self.state == DatReader.States.NONE:
                    line_join = &#39;&#39;.join(line)

                    if line_join[0] == &#39;S&#39; and line_join.startswith(&#39;STEP&#39;):
                        # checks for beginning of a new step
                        has_step_word = True
                        self.step_no = int(line[-1])
                        self.step_inc = 0
                        self.step_type = EDatAnalysisTypes.STATIC

                    elif line_join[0] == &#39;E&#39; and line_join.startswith(&#39;EIGENVALUENUMBER&#39;):
                        # chekcs for increment number in frequency or buckle step
                        self.step_inc = int(line[-1])
                        self.total_inc_no += 1

                    elif line_join[0] == &#39;I&#39; and line_join.startswith(&#39;INCREMENT&#39;):
                        # check for increment bumber in static step
                        self.step_inc = int(line[-1])
                        self.total_inc_no += 1

                    elif line_join[0] == &#39;E&#39; and line_join.startswith(&#39;EIGENVALUEOUTPUT&#39;):
                        # checks if step a frequency step
                        self.state = DatReader.States.FREQUENCY_INFO_OPEN
                        
                    elif line_join[0] == &#39;B&#39; and line_join.startswith(&#39;BUCKLINGFACTOROUTPUT&#39;):
                        # chekcs if step is a buckling step
                        self.state = DatReader.States.BUCKLING_INFO_OPEN
                        
                    elif &#39; &#39;.join(line).startswith(DatReader.dat_entities_str):
                        # if this line was reached without a &#34;STEP&#34; before, this file was written by ccx &lt; 2.22
                        if not has_step_word:
                            raise DatFileVersionError(&#34;This *.dat file was written by a ccx version &lt; 2.22.&#34;)
                        # cheks if a result set starts
                        try: # for safety. Should never raise. If so, line[0] doesn&#39;t initiate a result set
                            self._start_result_set(line)
                            self.state = DatReader.States.RESULT_SET_OPEN
                        except: pass

                # Handling new state
                # ---------------------------------------------------------       
                elif self.state == DatReader.States.RESULT_SET_OPEN: 
                    line = self._handle_result_set_open(line, stream)
                    self.state = DatReader.States.NONE
                    continue

                elif self.state == DatReader.States.BUCKLING_INFO_OPEN:
                    line = self._handle_buckling_info_open(line, stream)
                    self.state = DatReader.States.NONE
                    continue

                elif self.state == DatReader.States.FREQUENCY_INFO_OPEN:
                    line = self._handle_frequency_info_open(line, stream)
                    self.state = DatReader.States.NONE
                    continue

                line = next(stream, None)

            return DatResult(self.step_infos, tuple(self.result_sets))

        def _handle_result_set_open(self, line:list[str], stream:Generator[list[str], None, None]):

            while line:
                try:
                    id, data = _parse_data_line(line, self.entity_loc) # raises if line[0] is not numeric
                    self.value_dict[id].append(data)
                except: 
                    break
                line = next(stream, None)
            self._finish_result_set()
            return line
        
        def _handle_buckling_info_open(self, line:list[str], stream:Generator[list[str], None, None]):
            self.step_type = EDatAnalysisTypes.BUCKLE
            step_info = BuckleStepInfo(self.step_no, {})
            self.step_infos[self. step_no] = step_info

            while not _isnumeric(line[0]):
                line = next(stream, None)
            while line:
                try:
                    mode_no, factor = int(line[0]), float(line[1]) 
                    step_info._increment_infos[mode_no] = BuckleIncrementInfo(self.step_no, mode_no, factor)
                except:
                    break
                line = next(stream, None)
            return line

        def _handle_frequency_info_open(self, line:list[str], stream:Generator[list[str], None, None]):
            self.step_type = EDatAnalysisTypes.FREQUENCY


            freqs, part_facs, eff_mass, eigen_turn_dir = {},{},{},{}
            is_cyclic = False
            axis_reference_direction, total_eff_mass = None, None
            while not _isnumeric(line[0]):
                if line[0] == &#39;DIAMETER&#39;: is_cyclic = True
                line = next(stream, None)
            while line:
                try:
                    if is_cyclic:
                        diameter, mode_no, ev, w_real, f_real, w_imag = [float(x) for x in line]
                        diameter = int(diameter)
                    else:
                        mode_no, ev, w_real, f_real, w_imag = [float(x) for x in line]
                        diameter = None
                    freqs[int(mode_no)] = FreqencyInfo(ev, w_real, f_real, w_imag, diameter)
                except:
                    break
                line = next(stream, None)

            while line:
                line_join = &#39;&#39;.join(line)
                if line[0] == &#39;TOTAL&#39;: 
                    line = next(stream, None)
                elif line_join == &#39;PARTICIPATIONFACTORS&#39; or line_join == &#39;EFFECTIVEMODALMASS&#39;:
                    while not _isnumeric(line[0]):
                        line = next(stream, None)
                    while line:
                        try:
                            mode_no, vx, vy, vz, rx, ry, rz = [float(x) for x in line]
                            d = DofInfo(vx, vy, vz, rx, ry, rz)
                            if line_join[0] == &#39;P&#39;: part_facs[int(mode_no)] = d          
                            if line_join[0] == &#39;E&#39;: eff_mass[int(mode_no)] = d             
                        except:
                            break
                        line = next(stream, None)
                elif line_join == &#39;TOTALEFFECTIVEMASS&#39;:
                    while not _isnumeric(line[0]):
                        line = next(stream, None)  
                    while line:
                        try:
                            vx, vy, vz, rx, ry, rz = [float(x) for x in line]
                            total_eff_mass = DofInfo(vx, vy, vz, rx, ry, rz)                 
                        except:
                            break
                        line = next(stream, None)
                elif line_join == &#39;EIGENMODETURNINGDIRECTION&#39;:
                    while not _isnumeric(line[0]):
                        if &#39;&#39;.join(line).startswith(&#39;Axisreferencedirection&#39;):
                            axis_reference_direction = Vector(*[float(x) for x in line[-3:]])
                        line = next(stream, None) 
                    while line:
                        try:
                            node_dia, mode_no, dir = int(line[0]), int(line[1]), line[2]
                            eigen_turn_dir[mode_no] = EigenmodeTurningDirection(node_dia, dir)
                            total_eff_mass = DofInfo(vx, vy, vz, rx, ry, rz)                 
                        except:
                            break
                        line = next(stream, None)
                else:
                    break

            increment_infos = {mode_no:FrequencyIncrementInfo(self.step_no, mode_no, 
                                                        freqs[mode_no], part_facs[mode_no], 
                                                        eff_mass[mode_no], eigen_turn_dir.get(mode_no)) 
                                                        for mode_no in freqs}

            self.step_infos[self. step_no] = FrequencyStepInfo(self.step_no, increment_infos, 
                                                      total_eff_mass,
                                                      axis_reference_direction)

            return line

        def _start_result_set(self, line:list[str]):

            self.entity_name, self.set_name, self.step_time = _parse_header_line(line)
            self.component_names = _parse_header_components(line)
            self.entity_type = EDatEntities(self.entity_name)
            self.entity_loc = ENTITY_2_LOCATION_MAP[self.entity_type]                        
            self.value_dict = defaultdict(list)            

        def _finish_result_set(self) -&gt; DatResultSet:

            values_arr = _value_dict_to_value(self.value_dict, self.entity_loc)
            no_comp = _get_no_comp(values_arr)
            self.result_sets.append(DatResultSet(self.entity_type, no_comp, self.step_time, 
                                                self.step_no, self.step_inc, 
                                                self.step_type, self.set_name, 
                                                self.component_names[-no_comp:],values_arr, 
                                                self.entity_loc))  </code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.DatReader.States"><code class="name">var <span class="ident">States</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatReader.dat_entities_str"><code class="name">var <span class="ident">dat_entities_str</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResult"><code class="flex name class">
<span>class <span class="ident">DatResult</span></span>
<span>(</span><span>_step_infos:Â dict[int,Â <a title="pygccx.result_reader.dat_result.BuckleStepInfo" href="#pygccx.result_reader.dat_result.BuckleStepInfo">BuckleStepInfo</a>Â |Â <a title="pygccx.result_reader.dat_result.FrequencyStepInfo" href="#pygccx.result_reader.dat_result.FrequencyStepInfo">FrequencyStepInfo</a>], result_sets:Â tuple[<a title="pygccx.result_reader.dat_result.DatResultSet" href="#pygccx.result_reader.dat_result.DatResultSet">DatResultSet</a>,Â ...])</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing the content of a *.dat file. </p>
<p>Don't instanciate this class directly. Use DatResult.from_file() instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, slots=True)
class DatResult:
    &#34;&#34;&#34;
    Class representing the content of a *.dat file. 
    
    Don&#39;t instanciate this class directly. Use DatResult.from_file() instead.
    &#34;&#34;&#34;
    _step_infos:dict[int, StepInfo]
    &#34;&#34;&#34;Dictionary with increment infos for each step&#34;&#34;&#34;
    result_sets:tuple[DatResultSet, ...]
    &#34;&#34;&#34;Tuple with all result sets&#34;&#34;&#34;

    def get_step_info(self, step_no:int) -&gt; StepInfo|None:
        &#34;&#34;&#34;Returns the StepInfo for the given step_no.
        If step_no has no StepInfo, None is returned.

        Args:
            step_no (int): Step number for which StepInfos should be returned.

        Returns:
            StepInfo|None: StepInfo for step_no or None
        &#34;&#34;&#34;
        return self._step_infos.get(step_no)

    def get_available_times(self) -&gt; tuple[float, ...]:
        &#34;&#34;&#34;Returns a sorted tuple with all available times.&#34;&#34;&#34;
        return tuple(sorted({rs.step_time for rs in self.result_sets}))
    
    def get_result_sets_by(self,*,
                            entity:Optional[EDatEntities]=None,
                            step_no:Optional[int]=None,
                            step_inc_no:Optional[int]=None,
                            step_time:Optional[float]=None,
                            analysis_type:Optional[EDatAnalysisTypes]=None,
                            set_name:Optional[str]=None
                            ) -&gt; tuple[DatResultSet,...]:
        
        &#34;&#34;&#34;Returns a tuple with DatResultSets filtered by the given values.
        The kwarg step_time is applied at last, if given. 
        The results with the closest time to given step_time will be returned.

        Returns:
            tuple[DatResultsSet,...]: Filtered result sets
        &#34;&#34;&#34;

        rs = self.result_sets

        if entity is not None: rs = [r for r in rs if r.entity==entity]
        if step_no is not None: rs = [r for r in rs if r.step_no==step_no]
        if step_inc_no is not None: rs = [r for r in rs if r.step_inc_no==step_inc_no]
        if analysis_type is not None: rs = [r for r in rs if r.analysis_type==analysis_type]
        if set_name is not None: rs = [r for r in rs if r.set_name==set_name]
        if step_time is not None:
            available_times = {rs.step_time for rs in self.result_sets}
            nearest_time = min(available_times, key=lambda x:abs(x - step_time)) 
            rs = [r for r in rs if r.step_time==nearest_time]

        return tuple(rs)

    @classmethod
    def from_file(cls, filename:str) -&gt; &#39;DatResult&#39;:
        &#34;&#34;&#34;
        Creates a FrdResult from the given filename and returns it.

        IMPORTANT:
        Total result sets (with parameter TOTALS set in *NODE PRINT, *EL PRINT, etc)
        are not processed. These values can be obtained with simple numpy operations
        like np.sum() from the same result, if TOTALS is omitted.

        Args:
            filename (str): Path to ascii *.dat file

        Returns:
            DatResult
        &#34;&#34;&#34;

        with open(filename) as f:
            csv_reader = csv.reader(f, delimiter=&#39; &#39;, skipinitialspace=True)
            stream = (line for line in csv_reader if line) # filter out blank lines
            return DatReader()(stream)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.DatResult.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>filename:Â str) â€‘>Â <a title="pygccx.result_reader.dat_result.DatResult" href="#pygccx.result_reader.dat_result.DatResult">DatResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a FrdResult from the given filename and returns it.</p>
<p>IMPORTANT:
Total result sets (with parameter TOTALS set in <em>NODE PRINT, </em>EL PRINT, etc)
are not processed. These values can be obtained with simple numpy operations
like np.sum() from the same result, if TOTALS is omitted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to ascii *.dat file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DatResult</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, filename:str) -&gt; &#39;DatResult&#39;:
    &#34;&#34;&#34;
    Creates a FrdResult from the given filename and returns it.

    IMPORTANT:
    Total result sets (with parameter TOTALS set in *NODE PRINT, *EL PRINT, etc)
    are not processed. These values can be obtained with simple numpy operations
    like np.sum() from the same result, if TOTALS is omitted.

    Args:
        filename (str): Path to ascii *.dat file

    Returns:
        DatResult
    &#34;&#34;&#34;

    with open(filename) as f:
        csv_reader = csv.reader(f, delimiter=&#39; &#39;, skipinitialspace=True)
        stream = (line for line in csv_reader if line) # filter out blank lines
        return DatReader()(stream)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.DatResult.result_sets"><code class="name">var <span class="ident">result_sets</span> :Â tuple[<a title="pygccx.result_reader.dat_result.DatResultSet" href="#pygccx.result_reader.dat_result.DatResultSet">DatResultSet</a>,Â ...]</code></dt>
<dd>
<div class="desc"><p>Tuple with all result sets</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.DatResult.get_available_times"><code class="name flex">
<span>def <span class="ident">get_available_times</span></span>(<span>self) â€‘>Â tuple[float,Â ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sorted tuple with all available times.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_available_times(self) -&gt; tuple[float, ...]:
    &#34;&#34;&#34;Returns a sorted tuple with all available times.&#34;&#34;&#34;
    return tuple(sorted({rs.step_time for rs in self.result_sets}))</code></pre>
</details>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResult.get_result_sets_by"><code class="name flex">
<span>def <span class="ident">get_result_sets_by</span></span>(<span>self, *, entity:Â Optional[<a title="pygccx.enums.EDatEntities" href="../enums.html#pygccx.enums.EDatEntities">EDatEntities</a>]Â =Â None, step_no:Â Optional[int]Â =Â None, step_inc_no:Â Optional[int]Â =Â None, step_time:Â Optional[float]Â =Â None, analysis_type:Â Optional[<a title="pygccx.enums.EDatAnalysisTypes" href="../enums.html#pygccx.enums.EDatAnalysisTypes">EDatAnalysisTypes</a>]Â =Â None, set_name:Â Optional[str]Â =Â None) â€‘>Â tuple[<a title="pygccx.result_reader.dat_result.DatResultSet" href="#pygccx.result_reader.dat_result.DatResultSet">DatResultSet</a>,Â ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple with DatResultSets filtered by the given values.
The kwarg step_time is applied at last, if given.
The results with the closest time to given step_time will be returned.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[DatResultsSet,&hellip;]</code></dt>
<dd>Filtered result sets</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_result_sets_by(self,*,
                        entity:Optional[EDatEntities]=None,
                        step_no:Optional[int]=None,
                        step_inc_no:Optional[int]=None,
                        step_time:Optional[float]=None,
                        analysis_type:Optional[EDatAnalysisTypes]=None,
                        set_name:Optional[str]=None
                        ) -&gt; tuple[DatResultSet,...]:
    
    &#34;&#34;&#34;Returns a tuple with DatResultSets filtered by the given values.
    The kwarg step_time is applied at last, if given. 
    The results with the closest time to given step_time will be returned.

    Returns:
        tuple[DatResultsSet,...]: Filtered result sets
    &#34;&#34;&#34;

    rs = self.result_sets

    if entity is not None: rs = [r for r in rs if r.entity==entity]
    if step_no is not None: rs = [r for r in rs if r.step_no==step_no]
    if step_inc_no is not None: rs = [r for r in rs if r.step_inc_no==step_inc_no]
    if analysis_type is not None: rs = [r for r in rs if r.analysis_type==analysis_type]
    if set_name is not None: rs = [r for r in rs if r.set_name==set_name]
    if step_time is not None:
        available_times = {rs.step_time for rs in self.result_sets}
        nearest_time = min(available_times, key=lambda x:abs(x - step_time)) 
        rs = [r for r in rs if r.step_time==nearest_time]

    return tuple(rs)</code></pre>
</details>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResult.get_step_info"><code class="name flex">
<span>def <span class="ident">get_step_info</span></span>(<span>self, step_no:Â int) â€‘>Â <a title="pygccx.result_reader.dat_result.BuckleStepInfo" href="#pygccx.result_reader.dat_result.BuckleStepInfo">BuckleStepInfo</a>Â |Â <a title="pygccx.result_reader.dat_result.FrequencyStepInfo" href="#pygccx.result_reader.dat_result.FrequencyStepInfo">FrequencyStepInfo</a>Â |Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the StepInfo for the given step_no.
If step_no has no StepInfo, None is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_no</code></strong> :&ensp;<code>int</code></dt>
<dd>Step number for which StepInfos should be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>StepInfo|None: StepInfo for step_no or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_step_info(self, step_no:int) -&gt; StepInfo|None:
    &#34;&#34;&#34;Returns the StepInfo for the given step_no.
    If step_no has no StepInfo, None is returned.

    Args:
        step_no (int): Step number for which StepInfos should be returned.

    Returns:
        StepInfo|None: StepInfo for step_no or None
    &#34;&#34;&#34;
    return self._step_infos.get(step_no)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet"><code class="flex name class">
<span>class <span class="ident">DatResultSet</span></span>
<span>(</span><span>entity:Â <a title="pygccx.enums.EDatEntities" href="../enums.html#pygccx.enums.EDatEntities">EDatEntities</a>, no_components:Â int, step_time:Â float, step_no:Â int, step_inc_no:Â int, analysis_type:Â <a title="pygccx.enums.EDatAnalysisTypes" href="../enums.html#pygccx.enums.EDatAnalysisTypes">EDatAnalysisTypes</a>, set_name:Â str, component_names:Â tuple[str,Â ...], values:Â dict[int,Â numpy.ndarray[typing.Any,Â numpy.dtype[+ScalarType]]], entity_location:Â <a title="pygccx.enums.EResultLocations" href="../enums.html#pygccx.enums.EResultLocations">EResultLocations</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a result set from a *.dat file.</p>
<p>A result set contains the nodal, element or integration point result
values of an entity (i.e. U, S) for a single step time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, slots=True)
class DatResultSet:
    &#34;&#34;&#34;
    Class representing a result set from a *.dat file.

    A result set contains the nodal, element or integration point result 
    values of an entity (i.e. U, S) for a single step time.
    &#34;&#34;&#34;
    entity:EDatEntities
    &#34;&#34;&#34;Enum of the result set entity i.e. U, S&#34;&#34;&#34;
    no_components:int
    &#34;&#34;&#34;number of components per value. I.e. for a U result set no_components == 3&#34;&#34;&#34;
    step_time:float
    &#34;&#34;&#34;Step time of this result set&#34;&#34;&#34;
    step_no:int
    &#34;&#34;&#34;Step number of this result set since the beginning of the calculation.&#34;&#34;&#34;
    step_inc_no:int
    &#34;&#34;&#34;Increment number of this result set since the beginning of the step.
    Increment number for *STATIC, mode number for *FREQUENCY, factor number for *BUCKLE&#34;&#34;&#34;
    analysis_type:EDatAnalysisTypes
    &#34;&#34;&#34;Analysis type of this result set&#34;&#34;&#34;
    set_name:str
    &#34;&#34;&#34;Name of the node- or element set.&#34;&#34;&#34;
    component_names:tuple[str,...]
    &#34;&#34;&#34;Names of the value components. I.e. for a U result set (&#39;vx&#39;, &#39;vy&#39;, &#39;vz&#39;)&#34;&#34;&#34;
    values:dict[int, npt.NDArray] = field(repr=False)
    &#34;&#34;&#34;
    Dictionary with values.\n
    key = node id, 
    if entity_location==NODAL or ELEMENT: value = vector with entity components\n 
    if entity_location==INT_PNT: value = m x n array with m = number of int.pnts. and n = number of components.
    &#34;&#34;&#34;
    entity_location:EResultLocations
    &#34;&#34;&#34;Location of the result entity. i.e. NODAL, ELEMENT, ...&#34;&#34;&#34;


    def get_values_by_ids(self, ids:Iterable[int]) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Returns the result values for the given node or element ids as a numpy array.

        if entity_location==NODAL or ELEMENT: 
            2D Array is returned.
            len axis 0: number of given ids
            len axis 1: number of components.
        if entity_location==INT_PNT:
            3D Array is returned
            len axis 0: number of given ids
            len axis 1: number of int. pnts
            len axis 2: number of components

        The order of axis 0 is the same as ids.
        If ids is a non ordered iterable (i.e. a set) the ordering is arbitrary.

        If a node id is not in values an exception is raised. 
        &#34;&#34;&#34;
        return np.array([self.values[id] for id in ids])</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.DatResultSet.analysis_type"><code class="name">var <span class="ident">analysis_type</span> :Â <a title="pygccx.enums.EDatAnalysisTypes" href="../enums.html#pygccx.enums.EDatAnalysisTypes">EDatAnalysisTypes</a></code></dt>
<dd>
<div class="desc"><p>Analysis type of this result set</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.component_names"><code class="name">var <span class="ident">component_names</span> :Â tuple[str,Â ...]</code></dt>
<dd>
<div class="desc"><p>Names of the value components. I.e. for a U result set ('vx', 'vy', 'vz')</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.entity"><code class="name">var <span class="ident">entity</span> :Â <a title="pygccx.enums.EDatEntities" href="../enums.html#pygccx.enums.EDatEntities">EDatEntities</a></code></dt>
<dd>
<div class="desc"><p>Enum of the result set entity i.e. U, S</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.entity_location"><code class="name">var <span class="ident">entity_location</span> :Â <a title="pygccx.enums.EResultLocations" href="../enums.html#pygccx.enums.EResultLocations">EResultLocations</a></code></dt>
<dd>
<div class="desc"><p>Location of the result entity. i.e. NODAL, ELEMENT, &hellip;</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.no_components"><code class="name">var <span class="ident">no_components</span> :Â int</code></dt>
<dd>
<div class="desc"><p>number of components per value. I.e. for a U result set no_components == 3</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.set_name"><code class="name">var <span class="ident">set_name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Name of the node- or element set.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.step_inc_no"><code class="name">var <span class="ident">step_inc_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Increment number of this result set since the beginning of the step.
Increment number for <em>STATIC, mode number for </em>FREQUENCY, factor number for *BUCKLE</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.step_no"><code class="name">var <span class="ident">step_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Step number of this result set since the beginning of the calculation.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.step_time"><code class="name">var <span class="ident">step_time</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Step time of this result set</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DatResultSet.values"><code class="name">var <span class="ident">values</span> :Â dict[int,Â numpy.ndarray[typing.Any,Â numpy.dtype[+ScalarType]]]</code></dt>
<dd>
<div class="desc"><p>Dictionary with values.</p>
<p>key = node id,
if entity_location==NODAL or ELEMENT: value = vector with entity components</p>
<p>if entity_location==INT_PNT: value = m x n array with m = number of int.pnts. and n = number of components.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.DatResultSet.get_values_by_ids"><code class="name flex">
<span>def <span class="ident">get_values_by_ids</span></span>(<span>self, ids:Â Iterable[int]) â€‘>Â numpy.ndarray[typing.Any,Â numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the result values for the given node or element ids as a numpy array.</p>
<p>if entity_location==NODAL or ELEMENT:
2D Array is returned.
len axis 0: number of given ids
len axis 1: number of components.
if entity_location==INT_PNT:
3D Array is returned
len axis 0: number of given ids
len axis 1: number of int. pnts
len axis 2: number of components</p>
<p>The order of axis 0 is the same as ids.
If ids is a non ordered iterable (i.e. a set) the ordering is arbitrary.</p>
<p>If a node id is not in values an exception is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_values_by_ids(self, ids:Iterable[int]) -&gt; npt.NDArray[np.float64]:
    &#34;&#34;&#34;
    Returns the result values for the given node or element ids as a numpy array.

    if entity_location==NODAL or ELEMENT: 
        2D Array is returned.
        len axis 0: number of given ids
        len axis 1: number of components.
    if entity_location==INT_PNT:
        3D Array is returned
        len axis 0: number of given ids
        len axis 1: number of int. pnts
        len axis 2: number of components

    The order of axis 0 is the same as ids.
    If ids is a non ordered iterable (i.e. a set) the ordering is arbitrary.

    If a node id is not in values an exception is raised. 
    &#34;&#34;&#34;
    return np.array([self.values[id] for id in ids])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.DofInfo"><code class="flex name class">
<span>class <span class="ident">DofInfo</span></span>
<span>(</span><span>vx, vy, vz, rx, ry, rz)</span>
</code></dt>
<dd>
<div class="desc"><p>DofInfo(vx, vy, vz, rx, ry, rz)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.DofInfo.rx"><code class="name">var <span class="ident">rx</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DofInfo.ry"><code class="name">var <span class="ident">ry</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DofInfo.rz"><code class="name">var <span class="ident">rz</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DofInfo.vx"><code class="name">var <span class="ident">vx</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DofInfo.vy"><code class="name">var <span class="ident">vy</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.DofInfo.vz"><code class="name">var <span class="ident">vz</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.EigenmodeTurningDirection"><code class="flex name class">
<span>class <span class="ident">EigenmodeTurningDirection</span></span>
<span>(</span><span>nodal_diameter, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>EigenmodeTurningDirection(nodal_diameter, direction)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.EigenmodeTurningDirection.direction"><code class="name">var <span class="ident">direction</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.EigenmodeTurningDirection.nodal_diameter"><code class="name">var <span class="ident">nodal_diameter</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyIncrementInfo"><code class="flex name class">
<span>class <span class="ident">FrequencyIncrementInfo</span></span>
<span>(</span><span>step_no:Â int, step_inc_no:Â int, frequencies:Â <a title="pygccx.result_reader.dat_result.FrequencyInfo" href="#pygccx.result_reader.dat_result.FrequencyInfo">FrequencyInfo</a>, participation_factors:Â <a title="pygccx.result_reader.dat_result.DofInfo" href="#pygccx.result_reader.dat_result.DofInfo">DofInfo</a>, effective_modal_mass:Â <a title="pygccx.result_reader.dat_result.DofInfo" href="#pygccx.result_reader.dat_result.DofInfo">DofInfo</a>, eigenmode_turning_direction:Â <a title="pygccx.result_reader.dat_result.EigenmodeTurningDirection" href="#pygccx.result_reader.dat_result.EigenmodeTurningDirection">EigenmodeTurningDirection</a>Â |Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>FrequencyIncrementInfo(step_no: int, step_inc_no: int, frequencies: pygccx.result_reader.dat_result.FrequencyInfo, participation_factors: pygccx.result_reader.dat_result.DofInfo, effective_modal_mass: pygccx.result_reader.dat_result.DofInfo, eigenmode_turning_direction: pygccx.result_reader.dat_result.EigenmodeTurningDirection | None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, slots=True)  
class FrequencyIncrementInfo:
    step_no:int
    &#34;&#34;&#34;Step number of this result set since the beginning of the calculation.&#34;&#34;&#34;
    step_inc_no:int
    &#34;&#34;&#34;Increment number of this result set since the beginning of the step.
    In this context step_inc_no is the frequency mode number.&#34;&#34;&#34;
    frequencies: FreqencyInfo
    &#34;&#34;&#34;Named tuple with eigen value, frequency, angular velocity etc for this mode.&#34;&#34;&#34;
    participation_factors: DofInfo
    &#34;&#34;&#34;Named tuple with with participation factors in vx, vy, vz, rx, ry, rz for this mode.&#34;&#34;&#34;
    effective_modal_mass: DofInfo
    &#34;&#34;&#34;Named tuple with with effective modal mass in vx, vy, vz, rx, ry, rz for this mode.&#34;&#34;&#34;
    eigenmode_turning_direction:EigenmodeTurningDirection|None</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.FrequencyIncrementInfo.effective_modal_mass"><code class="name">var <span class="ident">effective_modal_mass</span> :Â <a title="pygccx.result_reader.dat_result.DofInfo" href="#pygccx.result_reader.dat_result.DofInfo">DofInfo</a></code></dt>
<dd>
<div class="desc"><p>Named tuple with with effective modal mass in vx, vy, vz, rx, ry, rz for this mode.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyIncrementInfo.eigenmode_turning_direction"><code class="name">var <span class="ident">eigenmode_turning_direction</span> :Â <a title="pygccx.result_reader.dat_result.EigenmodeTurningDirection" href="#pygccx.result_reader.dat_result.EigenmodeTurningDirection">EigenmodeTurningDirection</a>Â |Â None</code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyIncrementInfo.frequencies"><code class="name">var <span class="ident">frequencies</span> :Â <a title="pygccx.result_reader.dat_result.FrequencyInfo" href="#pygccx.result_reader.dat_result.FrequencyInfo">FrequencyInfo</a></code></dt>
<dd>
<div class="desc"><p>Named tuple with eigen value, frequency, angular velocity etc for this mode.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyIncrementInfo.participation_factors"><code class="name">var <span class="ident">participation_factors</span> :Â <a title="pygccx.result_reader.dat_result.DofInfo" href="#pygccx.result_reader.dat_result.DofInfo">DofInfo</a></code></dt>
<dd>
<div class="desc"><p>Named tuple with with participation factors in vx, vy, vz, rx, ry, rz for this mode.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyIncrementInfo.step_inc_no"><code class="name">var <span class="ident">step_inc_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Increment number of this result set since the beginning of the step.
In this context step_inc_no is the frequency mode number.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyIncrementInfo.step_no"><code class="name">var <span class="ident">step_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Step number of this result set since the beginning of the calculation.</p></div>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyInfo"><code class="flex name class">
<span>class <span class="ident">FreqencyInfo</span></span>
<span>(</span><span>eigen_value, omega_real, freq_real, omega_imag, nodal_diameter)</span>
</code></dt>
<dd>
<div class="desc"><p>FrequencyInfo(eigen_value, omega_real, freq_real, omega_imag, nodal_diameter)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.FrequencyInfo.eigen_value"><code class="name">var <span class="ident">eigen_value</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyInfo.freq_real"><code class="name">var <span class="ident">freq_real</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyInfo.nodal_diameter"><code class="name">var <span class="ident">nodal_diameter</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyInfo.omega_imag"><code class="name">var <span class="ident">omega_imag</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyInfo.omega_real"><code class="name">var <span class="ident">omega_real</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyStepInfo"><code class="flex name class">
<span>class <span class="ident">FrequencyStepInfo</span></span>
<span>(</span><span>step_no:Â int, _increment_infos:Â dict[int,Â <a title="pygccx.result_reader.dat_result.BuckleIncrementInfo" href="#pygccx.result_reader.dat_result.BuckleIncrementInfo">BuckleIncrementInfo</a>Â |Â <a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo">FrequencyIncrementInfo</a>], total_effective_mass:Â <a title="pygccx.result_reader.dat_result.DofInfo" href="#pygccx.result_reader.dat_result.DofInfo">DofInfo</a>, axis_reference_direction:Â <a title="pygccx.result_reader.dat_result.Vector" href="#pygccx.result_reader.dat_result.Vector">Vector</a>Â |Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>FrequencyStepInfo(step_no: int, _increment_infos: dict[int, pygccx.result_reader.dat_result.BuckleIncrementInfo | pygccx.result_reader.dat_result.FrequencyIncrementInfo], total_effective_mass: pygccx.result_reader.dat_result.DofInfo, axis_reference_direction: pygccx.result_reader.dat_result.Vector | None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, slots=True)  
class FrequencyStepInfo(StepInfoBase):
    total_effective_mass: DofInfo
    &#34;&#34;&#34;Named tuple with with total effective mass in vx, vy, vz, rx, ry, rz. Same for all modes&#34;&#34;&#34;
    axis_reference_direction: Vector|None
    &#34;&#34;&#34;Direction vector of the cyclic symmetry axis. Only available for cycliy symmetric frequency steps &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pygccx.result_reader.dat_result.StepInfoBase" href="#pygccx.result_reader.dat_result.StepInfoBase">StepInfoBase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.FrequencyStepInfo.axis_reference_direction"><code class="name">var <span class="ident">axis_reference_direction</span> :Â <a title="pygccx.result_reader.dat_result.Vector" href="#pygccx.result_reader.dat_result.Vector">Vector</a>Â |Â None</code></dt>
<dd>
<div class="desc"><p>Direction vector of the cyclic symmetry axis. Only available for cycliy symmetric frequency steps</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyStepInfo.step_no"><code class="name">var <span class="ident">step_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.FrequencyStepInfo.total_effective_mass"><code class="name">var <span class="ident">total_effective_mass</span> :Â <a title="pygccx.result_reader.dat_result.DofInfo" href="#pygccx.result_reader.dat_result.DofInfo">DofInfo</a></code></dt>
<dd>
<div class="desc"><p>Named tuple with with total effective mass in vx, vy, vz, rx, ry, rz. Same for all modes</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pygccx.result_reader.dat_result.StepInfoBase" href="#pygccx.result_reader.dat_result.StepInfoBase">StepInfoBase</a></b></code>:
<ul class="hlist">
<li><code><a title="pygccx.result_reader.dat_result.StepInfoBase.get_increment_infos" href="#pygccx.result_reader.dat_result.StepInfoBase.get_increment_infos">get_increment_infos</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pygccx.result_reader.dat_result.StepInfoBase"><code class="flex name class">
<span>class <span class="ident">StepInfoBase</span></span>
<span>(</span><span>step_no:Â int, _increment_infos:Â dict[int,Â <a title="pygccx.result_reader.dat_result.BuckleIncrementInfo" href="#pygccx.result_reader.dat_result.BuckleIncrementInfo">BuckleIncrementInfo</a>Â |Â <a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo">FrequencyIncrementInfo</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>StepInfoBase(step_no: int, _increment_infos: dict[int, pygccx.result_reader.dat_result.BuckleIncrementInfo | pygccx.result_reader.dat_result.FrequencyIncrementInfo])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True, slots=True)  
class StepInfoBase:
    step_no:int
    &#34;&#34;&#34;Step number of this result set since the beginning of the calculation.&#34;&#34;&#34;
    _increment_infos:dict[int, IncrementInfo]

    def get_increment_infos(self, *inc_no:int) -&gt; tuple[IncrementInfo|None]:
        &#34;&#34;&#34;Returns a tuple with IncrementInfos for the given increment numbers.

        Args:
            *inc_no (int): One or more increment numbers for which IncrementInfos should be returned.
                            If no inc_no is given, all increment infos are returned.

        Returns:
            tuple[IncrementInfo|None]: Tuple with IncrementInfos. Same order and length as inc_no.
            If there are no increment infos, an empty tuple is returned. 
            If an inc_no does not exist, the corresponding tuple element is None.
        &#34;&#34;&#34;

        if not inc_no: return tuple(self._increment_infos[i] for i in sorted(self._increment_infos))
        return tuple(self._increment_infos.get(i) for i in inc_no)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pygccx.result_reader.dat_result.BuckleStepInfo" href="#pygccx.result_reader.dat_result.BuckleStepInfo">BuckleStepInfo</a></li>
<li><a title="pygccx.result_reader.dat_result.BuckleStepInfo" href="#pygccx.result_reader.dat_result.BuckleStepInfo">BuckleStepInfo</a></li>
<li><a title="pygccx.result_reader.dat_result.FrequencyStepInfo" href="#pygccx.result_reader.dat_result.FrequencyStepInfo">FrequencyStepInfo</a></li>
<li><a title="pygccx.result_reader.dat_result.FrequencyStepInfo" href="#pygccx.result_reader.dat_result.FrequencyStepInfo">FrequencyStepInfo</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.StepInfoBase.step_no"><code class="name">var <span class="ident">step_no</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Step number of this result set since the beginning of the calculation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.StepInfoBase.get_increment_infos"><code class="name flex">
<span>def <span class="ident">get_increment_infos</span></span>(<span>self, *inc_no:Â int) â€‘>Â tuple[<a title="pygccx.result_reader.dat_result.BuckleIncrementInfo" href="#pygccx.result_reader.dat_result.BuckleIncrementInfo">BuckleIncrementInfo</a>Â |Â <a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo">FrequencyIncrementInfo</a>Â |Â None]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple with IncrementInfos for the given increment numbers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*inc_no</code></strong> :&ensp;<code>int</code></dt>
<dd>One or more increment numbers for which IncrementInfos should be returned.
If no inc_no is given, all increment infos are returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple[IncrementInfo|None]: Tuple with IncrementInfos. Same order and length as inc_no.
If there are no increment infos, an empty tuple is returned.
If an inc_no does not exist, the corresponding tuple element is None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_increment_infos(self, *inc_no:int) -&gt; tuple[IncrementInfo|None]:
    &#34;&#34;&#34;Returns a tuple with IncrementInfos for the given increment numbers.

    Args:
        *inc_no (int): One or more increment numbers for which IncrementInfos should be returned.
                        If no inc_no is given, all increment infos are returned.

    Returns:
        tuple[IncrementInfo|None]: Tuple with IncrementInfos. Same order and length as inc_no.
        If there are no increment infos, an empty tuple is returned. 
        If an inc_no does not exist, the corresponding tuple element is None.
    &#34;&#34;&#34;

    if not inc_no: return tuple(self._increment_infos[i] for i in sorted(self._increment_infos))
    return tuple(self._increment_infos.get(i) for i in inc_no)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pygccx.result_reader.dat_result.Vector"><code class="flex name class">
<span>class <span class="ident">Vector</span></span>
<span>(</span><span>x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Vector(x, y, z)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pygccx.result_reader.dat_result.Vector.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.Vector.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="pygccx.result_reader.dat_result.Vector.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygccx.result_reader" href="index.html">pygccx.result_reader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.BuckleIncrementInfo" href="#pygccx.result_reader.dat_result.BuckleIncrementInfo">BuckleIncrementInfo</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.BuckleIncrementInfo.buckling_factor" href="#pygccx.result_reader.dat_result.BuckleIncrementInfo.buckling_factor">buckling_factor</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.BuckleIncrementInfo.step_inc_no" href="#pygccx.result_reader.dat_result.BuckleIncrementInfo.step_inc_no">step_inc_no</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.BuckleIncrementInfo.step_no" href="#pygccx.result_reader.dat_result.BuckleIncrementInfo.step_no">step_no</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.BuckleStepInfo" href="#pygccx.result_reader.dat_result.BuckleStepInfo">BuckleStepInfo</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.BuckleStepInfo.step_no" href="#pygccx.result_reader.dat_result.BuckleStepInfo.step_no">step_no</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.DatFileVersionError" href="#pygccx.result_reader.dat_result.DatFileVersionError">DatFileVersionError</a></code></h4>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.DatReader" href="#pygccx.result_reader.dat_result.DatReader">DatReader</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.DatReader.States" href="#pygccx.result_reader.dat_result.DatReader.States">States</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatReader.dat_entities_str" href="#pygccx.result_reader.dat_result.DatReader.dat_entities_str">dat_entities_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.DatResult" href="#pygccx.result_reader.dat_result.DatResult">DatResult</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.DatResult.from_file" href="#pygccx.result_reader.dat_result.DatResult.from_file">from_file</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResult.get_available_times" href="#pygccx.result_reader.dat_result.DatResult.get_available_times">get_available_times</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResult.get_result_sets_by" href="#pygccx.result_reader.dat_result.DatResult.get_result_sets_by">get_result_sets_by</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResult.get_step_info" href="#pygccx.result_reader.dat_result.DatResult.get_step_info">get_step_info</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResult.result_sets" href="#pygccx.result_reader.dat_result.DatResult.result_sets">result_sets</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.DatResultSet" href="#pygccx.result_reader.dat_result.DatResultSet">DatResultSet</a></code></h4>
<ul class="two-column">
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.analysis_type" href="#pygccx.result_reader.dat_result.DatResultSet.analysis_type">analysis_type</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.component_names" href="#pygccx.result_reader.dat_result.DatResultSet.component_names">component_names</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.entity" href="#pygccx.result_reader.dat_result.DatResultSet.entity">entity</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.entity_location" href="#pygccx.result_reader.dat_result.DatResultSet.entity_location">entity_location</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.get_values_by_ids" href="#pygccx.result_reader.dat_result.DatResultSet.get_values_by_ids">get_values_by_ids</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.no_components" href="#pygccx.result_reader.dat_result.DatResultSet.no_components">no_components</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.set_name" href="#pygccx.result_reader.dat_result.DatResultSet.set_name">set_name</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.step_inc_no" href="#pygccx.result_reader.dat_result.DatResultSet.step_inc_no">step_inc_no</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.step_no" href="#pygccx.result_reader.dat_result.DatResultSet.step_no">step_no</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.step_time" href="#pygccx.result_reader.dat_result.DatResultSet.step_time">step_time</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DatResultSet.values" href="#pygccx.result_reader.dat_result.DatResultSet.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.DofInfo" href="#pygccx.result_reader.dat_result.DofInfo">DofInfo</a></code></h4>
<ul class="two-column">
<li><code><a title="pygccx.result_reader.dat_result.DofInfo.rx" href="#pygccx.result_reader.dat_result.DofInfo.rx">rx</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DofInfo.ry" href="#pygccx.result_reader.dat_result.DofInfo.ry">ry</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DofInfo.rz" href="#pygccx.result_reader.dat_result.DofInfo.rz">rz</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DofInfo.vx" href="#pygccx.result_reader.dat_result.DofInfo.vx">vx</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DofInfo.vy" href="#pygccx.result_reader.dat_result.DofInfo.vy">vy</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.DofInfo.vz" href="#pygccx.result_reader.dat_result.DofInfo.vz">vz</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.EigenmodeTurningDirection" href="#pygccx.result_reader.dat_result.EigenmodeTurningDirection">EigenmodeTurningDirection</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.EigenmodeTurningDirection.direction" href="#pygccx.result_reader.dat_result.EigenmodeTurningDirection.direction">direction</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.EigenmodeTurningDirection.nodal_diameter" href="#pygccx.result_reader.dat_result.EigenmodeTurningDirection.nodal_diameter">nodal_diameter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo">FrequencyIncrementInfo</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo.effective_modal_mass" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo.effective_modal_mass">effective_modal_mass</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo.eigenmode_turning_direction" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo.eigenmode_turning_direction">eigenmode_turning_direction</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo.frequencies" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo.frequencies">frequencies</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo.participation_factors" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo.participation_factors">participation_factors</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo.step_inc_no" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo.step_inc_no">step_inc_no</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyIncrementInfo.step_no" href="#pygccx.result_reader.dat_result.FrequencyIncrementInfo.step_no">step_no</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.FrequencyInfo" href="#pygccx.result_reader.dat_result.FrequencyInfo">FrequencyInfo</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.FrequencyInfo.eigen_value" href="#pygccx.result_reader.dat_result.FrequencyInfo.eigen_value">eigen_value</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyInfo.freq_real" href="#pygccx.result_reader.dat_result.FrequencyInfo.freq_real">freq_real</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyInfo.nodal_diameter" href="#pygccx.result_reader.dat_result.FrequencyInfo.nodal_diameter">nodal_diameter</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyInfo.omega_imag" href="#pygccx.result_reader.dat_result.FrequencyInfo.omega_imag">omega_imag</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyInfo.omega_real" href="#pygccx.result_reader.dat_result.FrequencyInfo.omega_real">omega_real</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.FrequencyStepInfo" href="#pygccx.result_reader.dat_result.FrequencyStepInfo">FrequencyStepInfo</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.FrequencyStepInfo.axis_reference_direction" href="#pygccx.result_reader.dat_result.FrequencyStepInfo.axis_reference_direction">axis_reference_direction</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyStepInfo.step_no" href="#pygccx.result_reader.dat_result.FrequencyStepInfo.step_no">step_no</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.FrequencyStepInfo.total_effective_mass" href="#pygccx.result_reader.dat_result.FrequencyStepInfo.total_effective_mass">total_effective_mass</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.StepInfoBase" href="#pygccx.result_reader.dat_result.StepInfoBase">StepInfoBase</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.StepInfoBase.get_increment_infos" href="#pygccx.result_reader.dat_result.StepInfoBase.get_increment_infos">get_increment_infos</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.StepInfoBase.step_no" href="#pygccx.result_reader.dat_result.StepInfoBase.step_no">step_no</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pygccx.result_reader.dat_result.Vector" href="#pygccx.result_reader.dat_result.Vector">Vector</a></code></h4>
<ul class="">
<li><code><a title="pygccx.result_reader.dat_result.Vector.x" href="#pygccx.result_reader.dat_result.Vector.x">x</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.Vector.y" href="#pygccx.result_reader.dat_result.Vector.y">y</a></code></li>
<li><code><a title="pygccx.result_reader.dat_result.Vector.z" href="#pygccx.result_reader.dat_result.Vector.z">z</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>