<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pygccx.helper_features.test.test_coordinate_system API documentation</title>
<meta name="description" content="Copyright Matthias Sedlmaier 2022
This file is part of pygccx â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pygccx.helper_features.test.test_coordinate_system</code></h1>
</header>
<section id="section-intro">
<p>Copyright Matthias Sedlmaier 2022
This file is part of pygccx.</p>
<p>pygccx is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.</p>
<p>pygccx is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with pygccx.<br>
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Copyright Matthias Sedlmaier 2022
This file is part of pygccx.

pygccx is free software: you can redistribute it 
and/or modify it under the terms of the GNU General Public License as 
published by the Free Software Foundation, either version 3 of the 
License, or (at your option) any later version.

pygccx is distributed in the hope that it will 
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pygccx.  
If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#39;&#39;&#39;

from unittest import TestCase

from pygccx.helper_features import CoordinateSystem
from pygccx.enums import EOrientationSystems
import numpy as np

class TestCoordinateSystem(TestCase):

    def test_default(self):
        c = CoordinateSystem(&#39;C1&#39;)
        known_mat = np.array([[1,0,0],[0,1,0],[0,0,1]], dtype=float)
        known_ori = np.zeros(3)
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))
        self.assertTrue(np.allclose(known_ori, c.get_origin()))

    def test_origin_param(self):
        # tests also set_origin(), because its called in __post_init__
        known_ori = np.array([2, 4, 6])
        c = CoordinateSystem(&#39;C1&#39;, origin=known_ori)
        self.assertTrue(np.allclose(known_ori, c.get_origin()))

    def test_origin_param_wrong_length(self):
        self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, origin=[2, 4, 6, 8])

    def test_matrix_param_wrong_length(self):
        self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, matrix=[[1,0,0],[0,1,0],[0,0,1],[0,0,0]])

    def test_matrix_param_not_all_rows_length_3(self):
        self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, matrix=[[1,0,0],[0,1,0],[0,0,1,0]])

    def test_matrix_param(self):
        # tests also set_matrix(), because its called in __post_init__
        known_mat = np.array([[0,1,0],[-1,0,0],[0,0,1]], dtype=float)
        c = CoordinateSystem(&#39;C1&#39;, matrix=known_mat)
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))

    def test_move(self):
        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1,2,3])
        self.assertTrue(np.allclose([1,2,3], c.get_origin()))
        c.move([1,2,3])
        self.assertTrue(np.allclose([2,4,6], c.get_origin()))

    def test_rotate(self):
        c = CoordinateSystem(&#39;C1&#39;)
        c.rotate_x(90, degrees=True)
        known_mat = np.array([[1, 0, 0],
                              [0, 0, 1],
                              [0, -1, 0]])
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))

        c.rotate_y(90, degrees=True)
        known_mat = np.array([[0, 1, 0],
                              [0, 0, 1],
                              [1, 0, 0]])
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))

        c.rotate_z(90, degrees=True)
        known_mat = np.array([[0, 0, 1],
                              [0, -1, 0],
                              [1, 0, 0]])
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))

    def test_transform_point_from_global_exception(self):
        c = CoordinateSystem(&#39;C1&#39;)

        self.assertRaises(ValueError, c.transform_point_from_global, [0.])
        self.assertRaises(ValueError, c.transform_point_from_global, [0., 0.])
        self.assertRaises(ValueError, c.transform_point_from_global, [0., 0., 0., 0.])
        self.assertRaises(ValueError, c.transform_point_from_global, [[0., 0., 0.]])

    def test_transform_point_from_global_into_rectangular(self):

        # Test coincident cosy
        # ------------------------------------------------------------------
        # outpu must be input, because local and global system are coincident.
        c = CoordinateSystem(&#39;C1&#39;)

        # test one point
        glob_pnt = np.array([-6,4,7], dtype=float)
        loc_pnt = c.transform_point_from_global(glob_pnt)
        self.assertTrue(np.allclose(glob_pnt, loc_pnt))

        # Test translated and rotated Cosy
        # ------------------------------------------------------------------
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        glob_pnts = [[0,0,0],
                     [1,1,1],
                     [1,2,3],
                     [-6,4,7]]
        loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]
        loc_pnts_ref = [[-2.7209705, 9.8683531e-002, 3.685998],
                        [-1.5682088, 0.77080594, 4.7902588],
                        [-1.4341189, 2.2315704, 6.477916],
                        [-6.8625229, 8.4420236, 7.4590895]] 
                    # calculated with ANSYS Workbench Mechanical
        
        for p1, p2 in zip(loc_pnts, loc_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 7)

    def test_transform_point_from_global_into_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)

        # test one point
        glob_pnt = np.array([-6,4,7], dtype=float)
        loc_pnt = c.transform_point_from_global(glob_pnt)
        loc_pnt_ref = np.array([7.2111026, np.deg2rad(146.30993), 7.])
                      # calculated with ANSYS Workbench Mechanical

        for c1, c2 in zip(loc_pnt, loc_pnt_ref):
            self.assertAlmostEqual(c1, c2, 7) #type: ignore

        # test multiple points
        glob_pnts = [[0,0,0],
                    [1,1,1],
                    [1,2,3],
                    [-6,4,7]]
        
        loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]

        loc_pnts_ref =[[0.,     0.,     0.],
                        [1.4142136,     np.deg2rad(45.),        1.],
                        [2.236068,      np.deg2rad(63.434949),  3.],
                        [7.2111026,     np.deg2rad(146.30993),  7.]]
                    # calculated with ANSYS Workbench Mechanical
        for p1, p2 in zip(loc_pnts, loc_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

        # Test translated and rotated Cosy
        # ------------------------------------------------------------------
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]
        
        loc_pnts_ref =[[2.7227594,      np.deg2rad(177.92292),  3.685998],
                        [1.747404,      np.deg2rad(153.82496),  4.7902588],
                        [2.6526597,     np.deg2rad(122.72683),  6.477916],
                        [10.879429,     np.deg2rad(129.10767),  7.4590895]]
                       # calculated with ANSYS Workbench Mechanical

        for p1, p2 in zip(loc_pnts, loc_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_global_exception(self):
        c = CoordinateSystem(&#39;C1&#39;)

        self.assertRaises(ValueError, c.transform_point_to_global, [0.])
        self.assertRaises(ValueError, c.transform_point_to_global, [0., 0.])
        self.assertRaises(ValueError, c.transform_point_to_global, [0., 0., 0., 0.])
        self.assertRaises(ValueError, c.transform_point_to_global, [[0., 0., 0.]])

    def test_transform_point_to_global_from_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)

        # test one point
        loc_pnt = np.array([-6,4,7], dtype=float)
        glob_pnt = c.transform_point_to_global(loc_pnt)
        self.assertTrue(np.allclose(glob_pnt, loc_pnt))

        # test multiple points
        loc_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                    [-1.5682088, 0.77080594,   4.7902588],
                    [-1.4341189, 2.23157040,   6.477916],
                    [-6.8625229, 8.44202360,   7.4590895]]
                    # calculated with ANSYS Workbench Mechanical
        
        glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

        self.assertTrue(np.allclose(glob_pnts, loc_pnts))

        # Test translated and rotated Cosy
        # ------------------------------------------------------------------
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]
        glob_pnts_ref = [[ 0., 0., 0.],
                        [ 1., 1., 1.],
                        [ 1., 2., 3.],
                        [-6., 4., 7.]] 
                    # calculated with ANSYS Workbench Mechanical
        
        for p1, p2 in zip(glob_pnts, glob_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_global_from_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)

        # test one point
        loc_pnt = [7.2111026, np.deg2rad(146.30993), 7.]
        # calculated with ANSYS Workbench Mechanical

        glob_pnt = c.transform_point_to_global(loc_pnt)
        glob_pnt_ref = np.array([-6,4,7], dtype=float)
                      
        for c1, c2 in zip(glob_pnt, glob_pnt_ref):
            self.assertAlmostEqual(c1, c2, 6) #type: ignore

        # test multiple points
        loc_pnts = [[0.,        0.,     0.],
                    [1.4142136, np.deg2rad(45.),        1.],
                    [2.236068,  np.deg2rad(63.434949),  3.],
                    [7.2111026, np.deg2rad(146.30993),  7.]]
                    # calculated with ANSYS Workbench Mechanical
        
        glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

        glob_pnts_ref = [[ 0., 0., 0.],
                        [ 1., 1., 1.],
                        [ 1., 2., 3.],
                        [-6., 4., 7.]]

        for p1, p2 in zip(glob_pnts, glob_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

        # Test translated and rotated Cosy
        # ------------------------------------------------------------------
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)

        loc_pnts = [[2.7227594, np.deg2rad(177.92292),  3.685998],
                    [1.747404,  np.deg2rad(153.82496),  4.7902588],
                    [2.6526597, np.deg2rad(122.72683),  6.477916],
                    [10.879429, np.deg2rad(129.10767),  7.4590895]] 
                    # calculated with ANSYS Workbench Mechanical
        
        glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

        for p1, p2 in zip(glob_pnts, glob_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_other_from_rectangular_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                    [-1.5682088, 0.77080594,   4.7902588],
                    [-1.4341189, 2.23157040,   6.477916],
                    [-6.8625229, 8.44202360,   7.4590895]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts_ref =  [[-1.4552322,    1.8868577, -9.6084373],
                        [-6.7625066e-2, 2.3583302, -8.6852579],
                        [ 0.85277961,   4.1644548, -7.7414523],
                        [-0.75323817,  11.884473, -10.353354]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
        
        for p1, p2 in zip(c2_pnts, c2_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_other_from_rectangular_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                    [-1.5682088, 0.77080594,   4.7902588],
                    [-1.4341189, 2.23157040,   6.477916],
                    [-6.8625229, 8.44202360,   7.4590895]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts_ref = [[2.3828414,      np.deg2rad(127.64108),  -9.6084373],
                        [2.3592996,     np.deg2rad(91.642505),  -8.6852579],
                        [4.2508725,     np.deg2rad(78.427201),  -7.7414523],
                        [11.908319,     np.deg2rad(93.626557),  -10.353354]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
        
        for p1, p2 in zip(c2_pnts, c2_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_other_from_cylindrical_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_pnts = [[2.7227594,  np.deg2rad(177.92292),  3.685998],
                    [1.747404, np.deg2rad(153.82496),   4.7902588],
                    [2.6526597, np.deg2rad(122.72683),  6.477916],
                    [10.879429, np.deg2rad(129.10767),  7.4590895]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts_ref =  [[-1.4552322,    1.8868577, -9.6084373],
                        [-6.7625066e-2, 2.3583302, -8.6852579],
                        [ 0.85277961,   4.1644548, -7.7414523],
                        [-0.75323817,  11.884473, -10.353354]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
        
        for p1, p2 in zip(c2_pnts, c2_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 5)

    def test_transform_point_to_other_from_cylindrical_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_pnts = [[2.7227594,  np.deg2rad(177.92292),  3.685998],
                    [1.747404, np.deg2rad(153.82496),   4.7902588],
                    [2.6526597, np.deg2rad(122.72683),  6.477916],
                    [10.879429, np.deg2rad(129.10767),  7.4590895]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts_ref = [[2.3828414,      np.deg2rad(127.64108),  -9.6084373],
                        [2.3592996,     np.deg2rad(91.642505),  -8.6852579],
                        [4.2508725,     np.deg2rad(78.427201),  -7.7414523],
                        [11.908319,     np.deg2rad(93.626557),  -10.353354]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
        
        for p1, p2 in zip(c2_pnts, c2_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 5)

    def test_transform_vector_from_global_into_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test one point
        glob_vec = [1.,1.,1.]
        loc_vec = c.transform_vector_from_global(glob_vec)
        loc_vec_ref = [1.1527617, 0.67212241, 1.1042608]

        for c1, c2 in zip(loc_vec, loc_vec_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # # test multiple points
        glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
        loc_vec = [c.transform_vector_from_global(glob_vec) for glob_vec in glob_vecs]
        loc_vec_ref = [[1.1527617, 0.67212241, 1.1042608],
                       [3.592375, 3.4771317, 5.0004397]]
        for v1, v2 in zip(loc_vec, loc_vec_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_from_global_into_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test one vector, one ref point
        glob_vec = [1.,1.,1.]
        glob_pnt = [-6.,4.,7.]
        loc_vec = c.transform_vector_from_global(glob_vec, glob_pnt)
        loc_vec_ref = [-0.2055972, -1.3184604, 1.1042608]

        for c1, c2 in zip(loc_vec, loc_vec_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test multiple vectors, one ref point
        glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
        glob_pnt = [-6.,4.,7.]
        loc_vec = [c.transform_vector_from_global(glob_vec, glob_pnt) for glob_vec in glob_vecs]
        loc_vec_ref = [[-0.2055972, -1.3184604, 1.1042608],
                       [0.43212494, -4.9808504, 5.0004397]]
        for v1, v2 in zip(loc_vec, loc_vec_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

        # test multiple vectors, multiple ref points
        glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
        glob_pnts = [[-6.,4.,7.], [-6.,4.,7.]]
        loc_vec = [c.transform_vector_from_global(glob_vec, glob_pnt) 
                   for glob_vec, glob_pnt in zip(glob_vecs, glob_pnts)]
        
        loc_vec_ref = [[-0.2055972, -1.3184604, 1.1042608],
                       [0.43212494, -4.9808504, 5.0004397]]
        for v1, v2 in zip(loc_vec, loc_vec_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_global_from_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test one point
        loc_vec = [1.1527617, 0.67212241, 1.1042608]
        glob_vec = c.transform_vector_to_global(loc_vec)
        glob_vec_ref = [1.,1.,1.]
        
        for c1, c2 in zip(glob_vec, glob_vec_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test multiple points
        loc_vecs = [[1.1527617, 0.67212241, 1.1042608],
                       [3.592375, 3.4771317, 5.0004397]]
        glob_vecs = [c.transform_vector_to_global(loc_vec) for loc_vec in loc_vecs]
        glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]

        for v1, v2 in zip(glob_vecs, glob_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_global_from_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test one vector, one ref point
        loc_vec = [-0.2055972, -1.3184604, 1.1042608]
        loc_pnt = [10.879429,   np.deg2rad(129.10767),  7.4590895]
        glob_vec = c.transform_vector_to_global(loc_vec, loc_pnt)
        glob_vec_ref = [1.,1.,1.]
        for c1, c2 in zip(glob_vec, glob_vec_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test multiple vectors, one ref point     
        loc_vecs = [[-0.2055972, -1.3184604, 1.1042608],
                       [0.43212494, -4.9808504, 5.0004397]]
        loc_pnt = [10.879429,   np.deg2rad(129.10767),  7.4590895]
        glob_vecs = [c.transform_vector_to_global(loc_vec, loc_pnt) for loc_vec in loc_vecs]
        glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]
        for v1, v2 in zip(glob_vecs, glob_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

        # test multiple vectors, multiple ref points
        
        loc_vecs = [[-0.2055972, -1.3184604, 1.1042608],
                    [0.43212494, -4.9808504, 5.0004397]]
        loc_pnts = [[10.879429, np.deg2rad(129.10767),  7.4590895], 
                     [10.879429,        np.deg2rad(129.10767),  7.4590895]]
        glob_vecs = [c.transform_vector_to_global(loc_vec, loc_pnt) 
                   for loc_vec, loc_pnt in zip(loc_vecs, loc_pnts)]
        glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]

        for v1, v2 in zip(glob_vecs, glob_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_other_from_rectangular_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_vecs = [[6, 7, 8],
                   [6, -7, 8]]

        c2_vecs_ref =  [[9.060223, 6.1417899, 5.4028489],
                        [2.1604354, -4.6338814, 11.084208]]
                    # calculated with ANSYS Workbench Mechanical

        c2_vecs = [c1.transform_vector_to_other(c2, c1_vec) for c1_vec in c1_vecs]
        
        for v1, v2 in zip(c2_vecs, c2_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_other_from_rectangular_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        ref_point = [-6.8625229, 8.4420236, 7.4590895]
        # ref point in c1 at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

        c1_vecs = [[6, 7, 8],
                   [6, -7, 8]]

        c2_vecs_ref =  [[5.5564038, -9.4305674, 5.4028489],
                        [-4.7612564, -1.8630018, 11.084208]]
                    # calculated with ANSYS Workbench Mechanical

        c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
        
        for v1, v2 in zip(c2_vecs, c2_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_other_from_cylindrical_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        ref_point = [10.879429, np.deg2rad(129.10767),  7.4590895]
        # ref point in c1_cyl at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

        c1_vecs = [[6, 7, 8],
                   [6, -7, 8]]

        c2_vecs_ref =  [[-7.4896431, 7.9677196, 5.4240843],
                        [6.2996349, 9.7467169, 3.7836636]]
                    # calculated with ANSYS Workbench Mechanical

        c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
        
        for v1, v2 in zip(c2_vecs, c2_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 5)

    def test_transform_vector_to_other_from_cylindrical_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        ref_point = [10.879429, np.deg2rad(129.10767),  7.4590895]
        # ref point in c1_cyl at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

        c1_vecs = [[6, 7, 8],
                   [6, -7, 8]]

        c2_vecs_ref =  [[8.4255076, 6.9706622, 5.4240843],
                        [9.3287278, -6.9035301, 3.7836636]]
                    # calculated with ANSYS Workbench Mechanical

        c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
        
        for v1, v2 in zip(c2_vecs, c2_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 5)

    def test_transform_tensor_from_global_into_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test as vector
        glob_tens = [0., -1., 0., 0., 0.,0.]
        loc_tens = c.transform_tensor_from_global(glob_tens)
        loc_tens_ref = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]

        for c1, c2 in zip(loc_tens, loc_tens_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test as matrix
        glob_tens = [[0, 0, 0],
                     [0,-1, 0],
                     [0, 0, 0]]
        loc_tens = c.transform_tensor_from_global(glob_tens)
        loc_tens_ref = [[-0.29575993, -0.44767285, 0.088741284],
                        [-0.44767285, -0.6776137,  0.134322],
                        [0.088741284,  0.134322,  -0.026626378]]
        
        for row, row_ref in zip(loc_tens, loc_tens_ref):
            for c1, c2 in zip(row, row_ref):
                self.assertAlmostEqual(c1, c2, 6) 

    def test_transform_tensor_from_global_into_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type= EOrientationSystems.CYLINDRICAL)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test as vector
        glob_tens = [0., -1., 0., 0., 0.,0.]
        ref_pnt = [30,30,30]
        loc_tens = c.transform_tensor_from_global(glob_tens, ref_pnt)
        loc_tens_ref = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]

        for c1, c2 in zip(loc_tens, loc_tens_ref):
            self.assertAlmostEqual(c1, c2, 6)

    def test_transform_tensor_to_global_from_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test as vector
        glob_tens_ref = [0., -1., 0., 0., 0.,0.]
        loc_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]
        glob_tens = c.transform_tensor_to_global(loc_tens)
        

        for c1, c2 in zip(glob_tens, glob_tens_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test as matrix
        glob_tens_ref = [[0, 0, 0],
                        [0,-1, 0],
                        [0, 0, 0]]
        loc_tens = [[-0.29575993, -0.44767285, 0.088741284],
                        [-0.44767285, -0.6776137,  0.134322],
                        [0.088741284,  0.134322,  -0.026626378]]
        glob_tens = c.transform_tensor_to_global(loc_tens)
        
        for row, row_ref in zip(glob_tens, glob_tens_ref):
            for c1, c2 in zip(row, row_ref):
                self.assertAlmostEqual(c1, c2, 6) 

    def test_transform_tensor_to_global_from_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type= EOrientationSystems.CYLINDRICAL)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test as vector
        glob_tens_ref = [0., -1., 0., 0., 0.,0.]
        ref_pnt = [37.759005, 0.56643013, 36.813822]
        loc_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
        glob_tens = c.transform_tensor_to_global(loc_tens, ref_pnt)
        

        for c1, c2 in zip(glob_tens, glob_tens_ref):
            self.assertAlmostEqual(c1, c2, 6)

    def test_transform_tensor_to_other_from_rectangular_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]

        c2_tens_ref =  [-0.75690331, -9.6390665e-002, -0.14670602, -0.27010815, 0.11891632, 0.33323006]
                    # calculated with ANSYS Workbench Mechanical

        c2_tens = c1.transform_tensor_to_other(c2, c1_tens)
        
        for v1, v2 in zip(c2_tens, c2_tens_ref):
            self.assertAlmostEqual(v1, v2, 6)

    def test_transform_tensor_to_other_from_rectangular_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]
        ref_pnt = [31.86188, 20.262356, 36.813822]


        c2_tens_ref =  [-0.85213174, -1.1622426e-003, -0.14670602, 3.1470364e-002, -1.3057871e-002, 0.35357157]
                    # calculated with ANSYS Workbench Mechanical

        c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
        
        for v1, v2 in zip(c2_tens, c2_tens_ref):
            self.assertAlmostEqual(v1, v2, 6)

    def test_transform_tensor_to_other_from_cylindrical_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
        ref_pnt = [37.759005, 0.56643013, 36.813822]
        c2_tens_ref =  [-0.75690331, -9.6390665e-002, -0.14670602, -0.27010815, 0.11891632, 0.33323006]
                    # calculated with ANSYS Workbench Mechanical

        c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
        
        for v1, v2 in zip(c2_tens, c2_tens_ref):
            self.assertAlmostEqual(v1, v2, 6)

    def test_transform_tensor_to_other_from_cylindrical_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
        ref_pnt = [37.759005, 0.56643013, 36.813822]
        c2_tens_ref =  c2_tens_ref =  [-0.85213174, -1.1622426e-003, -0.14670602, 3.1470364e-002, -1.3057871e-002, 0.35357157]
                    # calculated with ANSYS Workbench Mechanical

        c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
        
        for v1, v2 in zip(c2_tens, c2_tens_ref):
            self.assertAlmostEqual(v1, v2, 6)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem"><code class="flex name class">
<span>class <span class="ident">TestCoordinateSystem</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestCoordinateSystem(TestCase):

    def test_default(self):
        c = CoordinateSystem(&#39;C1&#39;)
        known_mat = np.array([[1,0,0],[0,1,0],[0,0,1]], dtype=float)
        known_ori = np.zeros(3)
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))
        self.assertTrue(np.allclose(known_ori, c.get_origin()))

    def test_origin_param(self):
        # tests also set_origin(), because its called in __post_init__
        known_ori = np.array([2, 4, 6])
        c = CoordinateSystem(&#39;C1&#39;, origin=known_ori)
        self.assertTrue(np.allclose(known_ori, c.get_origin()))

    def test_origin_param_wrong_length(self):
        self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, origin=[2, 4, 6, 8])

    def test_matrix_param_wrong_length(self):
        self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, matrix=[[1,0,0],[0,1,0],[0,0,1],[0,0,0]])

    def test_matrix_param_not_all_rows_length_3(self):
        self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, matrix=[[1,0,0],[0,1,0],[0,0,1,0]])

    def test_matrix_param(self):
        # tests also set_matrix(), because its called in __post_init__
        known_mat = np.array([[0,1,0],[-1,0,0],[0,0,1]], dtype=float)
        c = CoordinateSystem(&#39;C1&#39;, matrix=known_mat)
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))

    def test_move(self):
        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1,2,3])
        self.assertTrue(np.allclose([1,2,3], c.get_origin()))
        c.move([1,2,3])
        self.assertTrue(np.allclose([2,4,6], c.get_origin()))

    def test_rotate(self):
        c = CoordinateSystem(&#39;C1&#39;)
        c.rotate_x(90, degrees=True)
        known_mat = np.array([[1, 0, 0],
                              [0, 0, 1],
                              [0, -1, 0]])
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))

        c.rotate_y(90, degrees=True)
        known_mat = np.array([[0, 1, 0],
                              [0, 0, 1],
                              [1, 0, 0]])
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))

        c.rotate_z(90, degrees=True)
        known_mat = np.array([[0, 0, 1],
                              [0, -1, 0],
                              [1, 0, 0]])
        self.assertTrue(np.allclose(known_mat, c.get_matrix()))

    def test_transform_point_from_global_exception(self):
        c = CoordinateSystem(&#39;C1&#39;)

        self.assertRaises(ValueError, c.transform_point_from_global, [0.])
        self.assertRaises(ValueError, c.transform_point_from_global, [0., 0.])
        self.assertRaises(ValueError, c.transform_point_from_global, [0., 0., 0., 0.])
        self.assertRaises(ValueError, c.transform_point_from_global, [[0., 0., 0.]])

    def test_transform_point_from_global_into_rectangular(self):

        # Test coincident cosy
        # ------------------------------------------------------------------
        # outpu must be input, because local and global system are coincident.
        c = CoordinateSystem(&#39;C1&#39;)

        # test one point
        glob_pnt = np.array([-6,4,7], dtype=float)
        loc_pnt = c.transform_point_from_global(glob_pnt)
        self.assertTrue(np.allclose(glob_pnt, loc_pnt))

        # Test translated and rotated Cosy
        # ------------------------------------------------------------------
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        glob_pnts = [[0,0,0],
                     [1,1,1],
                     [1,2,3],
                     [-6,4,7]]
        loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]
        loc_pnts_ref = [[-2.7209705, 9.8683531e-002, 3.685998],
                        [-1.5682088, 0.77080594, 4.7902588],
                        [-1.4341189, 2.2315704, 6.477916],
                        [-6.8625229, 8.4420236, 7.4590895]] 
                    # calculated with ANSYS Workbench Mechanical
        
        for p1, p2 in zip(loc_pnts, loc_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 7)

    def test_transform_point_from_global_into_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)

        # test one point
        glob_pnt = np.array([-6,4,7], dtype=float)
        loc_pnt = c.transform_point_from_global(glob_pnt)
        loc_pnt_ref = np.array([7.2111026, np.deg2rad(146.30993), 7.])
                      # calculated with ANSYS Workbench Mechanical

        for c1, c2 in zip(loc_pnt, loc_pnt_ref):
            self.assertAlmostEqual(c1, c2, 7) #type: ignore

        # test multiple points
        glob_pnts = [[0,0,0],
                    [1,1,1],
                    [1,2,3],
                    [-6,4,7]]
        
        loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]

        loc_pnts_ref =[[0.,     0.,     0.],
                        [1.4142136,     np.deg2rad(45.),        1.],
                        [2.236068,      np.deg2rad(63.434949),  3.],
                        [7.2111026,     np.deg2rad(146.30993),  7.]]
                    # calculated with ANSYS Workbench Mechanical
        for p1, p2 in zip(loc_pnts, loc_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

        # Test translated and rotated Cosy
        # ------------------------------------------------------------------
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]
        
        loc_pnts_ref =[[2.7227594,      np.deg2rad(177.92292),  3.685998],
                        [1.747404,      np.deg2rad(153.82496),  4.7902588],
                        [2.6526597,     np.deg2rad(122.72683),  6.477916],
                        [10.879429,     np.deg2rad(129.10767),  7.4590895]]
                       # calculated with ANSYS Workbench Mechanical

        for p1, p2 in zip(loc_pnts, loc_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_global_exception(self):
        c = CoordinateSystem(&#39;C1&#39;)

        self.assertRaises(ValueError, c.transform_point_to_global, [0.])
        self.assertRaises(ValueError, c.transform_point_to_global, [0., 0.])
        self.assertRaises(ValueError, c.transform_point_to_global, [0., 0., 0., 0.])
        self.assertRaises(ValueError, c.transform_point_to_global, [[0., 0., 0.]])

    def test_transform_point_to_global_from_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)

        # test one point
        loc_pnt = np.array([-6,4,7], dtype=float)
        glob_pnt = c.transform_point_to_global(loc_pnt)
        self.assertTrue(np.allclose(glob_pnt, loc_pnt))

        # test multiple points
        loc_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                    [-1.5682088, 0.77080594,   4.7902588],
                    [-1.4341189, 2.23157040,   6.477916],
                    [-6.8625229, 8.44202360,   7.4590895]]
                    # calculated with ANSYS Workbench Mechanical
        
        glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

        self.assertTrue(np.allclose(glob_pnts, loc_pnts))

        # Test translated and rotated Cosy
        # ------------------------------------------------------------------
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]
        glob_pnts_ref = [[ 0., 0., 0.],
                        [ 1., 1., 1.],
                        [ 1., 2., 3.],
                        [-6., 4., 7.]] 
                    # calculated with ANSYS Workbench Mechanical
        
        for p1, p2 in zip(glob_pnts, glob_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_global_from_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)

        # test one point
        loc_pnt = [7.2111026, np.deg2rad(146.30993), 7.]
        # calculated with ANSYS Workbench Mechanical

        glob_pnt = c.transform_point_to_global(loc_pnt)
        glob_pnt_ref = np.array([-6,4,7], dtype=float)
                      
        for c1, c2 in zip(glob_pnt, glob_pnt_ref):
            self.assertAlmostEqual(c1, c2, 6) #type: ignore

        # test multiple points
        loc_pnts = [[0.,        0.,     0.],
                    [1.4142136, np.deg2rad(45.),        1.],
                    [2.236068,  np.deg2rad(63.434949),  3.],
                    [7.2111026, np.deg2rad(146.30993),  7.]]
                    # calculated with ANSYS Workbench Mechanical
        
        glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

        glob_pnts_ref = [[ 0., 0., 0.],
                        [ 1., 1., 1.],
                        [ 1., 2., 3.],
                        [-6., 4., 7.]]

        for p1, p2 in zip(glob_pnts, glob_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

        # Test translated and rotated Cosy
        # ------------------------------------------------------------------
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)

        loc_pnts = [[2.7227594, np.deg2rad(177.92292),  3.685998],
                    [1.747404,  np.deg2rad(153.82496),  4.7902588],
                    [2.6526597, np.deg2rad(122.72683),  6.477916],
                    [10.879429, np.deg2rad(129.10767),  7.4590895]] 
                    # calculated with ANSYS Workbench Mechanical
        
        glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

        for p1, p2 in zip(glob_pnts, glob_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_other_from_rectangular_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                    [-1.5682088, 0.77080594,   4.7902588],
                    [-1.4341189, 2.23157040,   6.477916],
                    [-6.8625229, 8.44202360,   7.4590895]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts_ref =  [[-1.4552322,    1.8868577, -9.6084373],
                        [-6.7625066e-2, 2.3583302, -8.6852579],
                        [ 0.85277961,   4.1644548, -7.7414523],
                        [-0.75323817,  11.884473, -10.353354]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
        
        for p1, p2 in zip(c2_pnts, c2_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_other_from_rectangular_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                    [-1.5682088, 0.77080594,   4.7902588],
                    [-1.4341189, 2.23157040,   6.477916],
                    [-6.8625229, 8.44202360,   7.4590895]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts_ref = [[2.3828414,      np.deg2rad(127.64108),  -9.6084373],
                        [2.3592996,     np.deg2rad(91.642505),  -8.6852579],
                        [4.2508725,     np.deg2rad(78.427201),  -7.7414523],
                        [11.908319,     np.deg2rad(93.626557),  -10.353354]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
        
        for p1, p2 in zip(c2_pnts, c2_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_point_to_other_from_cylindrical_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_pnts = [[2.7227594,  np.deg2rad(177.92292),  3.685998],
                    [1.747404, np.deg2rad(153.82496),   4.7902588],
                    [2.6526597, np.deg2rad(122.72683),  6.477916],
                    [10.879429, np.deg2rad(129.10767),  7.4590895]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts_ref =  [[-1.4552322,    1.8868577, -9.6084373],
                        [-6.7625066e-2, 2.3583302, -8.6852579],
                        [ 0.85277961,   4.1644548, -7.7414523],
                        [-0.75323817,  11.884473, -10.353354]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
        
        for p1, p2 in zip(c2_pnts, c2_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 5)

    def test_transform_point_to_other_from_cylindrical_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_pnts = [[2.7227594,  np.deg2rad(177.92292),  3.685998],
                    [1.747404, np.deg2rad(153.82496),   4.7902588],
                    [2.6526597, np.deg2rad(122.72683),  6.477916],
                    [10.879429, np.deg2rad(129.10767),  7.4590895]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts_ref = [[2.3828414,      np.deg2rad(127.64108),  -9.6084373],
                        [2.3592996,     np.deg2rad(91.642505),  -8.6852579],
                        [4.2508725,     np.deg2rad(78.427201),  -7.7414523],
                        [11.908319,     np.deg2rad(93.626557),  -10.353354]]
                    # calculated with ANSYS Workbench Mechanical

        c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
        
        for p1, p2 in zip(c2_pnts, c2_pnts_ref):
            for c1, c2 in zip(p1, p2):
                self.assertAlmostEqual(c1, c2, 5)

    def test_transform_vector_from_global_into_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test one point
        glob_vec = [1.,1.,1.]
        loc_vec = c.transform_vector_from_global(glob_vec)
        loc_vec_ref = [1.1527617, 0.67212241, 1.1042608]

        for c1, c2 in zip(loc_vec, loc_vec_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # # test multiple points
        glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
        loc_vec = [c.transform_vector_from_global(glob_vec) for glob_vec in glob_vecs]
        loc_vec_ref = [[1.1527617, 0.67212241, 1.1042608],
                       [3.592375, 3.4771317, 5.0004397]]
        for v1, v2 in zip(loc_vec, loc_vec_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_from_global_into_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test one vector, one ref point
        glob_vec = [1.,1.,1.]
        glob_pnt = [-6.,4.,7.]
        loc_vec = c.transform_vector_from_global(glob_vec, glob_pnt)
        loc_vec_ref = [-0.2055972, -1.3184604, 1.1042608]

        for c1, c2 in zip(loc_vec, loc_vec_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test multiple vectors, one ref point
        glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
        glob_pnt = [-6.,4.,7.]
        loc_vec = [c.transform_vector_from_global(glob_vec, glob_pnt) for glob_vec in glob_vecs]
        loc_vec_ref = [[-0.2055972, -1.3184604, 1.1042608],
                       [0.43212494, -4.9808504, 5.0004397]]
        for v1, v2 in zip(loc_vec, loc_vec_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

        # test multiple vectors, multiple ref points
        glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
        glob_pnts = [[-6.,4.,7.], [-6.,4.,7.]]
        loc_vec = [c.transform_vector_from_global(glob_vec, glob_pnt) 
                   for glob_vec, glob_pnt in zip(glob_vecs, glob_pnts)]
        
        loc_vec_ref = [[-0.2055972, -1.3184604, 1.1042608],
                       [0.43212494, -4.9808504, 5.0004397]]
        for v1, v2 in zip(loc_vec, loc_vec_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_global_from_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test one point
        loc_vec = [1.1527617, 0.67212241, 1.1042608]
        glob_vec = c.transform_vector_to_global(loc_vec)
        glob_vec_ref = [1.,1.,1.]
        
        for c1, c2 in zip(glob_vec, glob_vec_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test multiple points
        loc_vecs = [[1.1527617, 0.67212241, 1.1042608],
                       [3.592375, 3.4771317, 5.0004397]]
        glob_vecs = [c.transform_vector_to_global(loc_vec) for loc_vec in loc_vecs]
        glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]

        for v1, v2 in zip(glob_vecs, glob_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_global_from_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test one vector, one ref point
        loc_vec = [-0.2055972, -1.3184604, 1.1042608]
        loc_pnt = [10.879429,   np.deg2rad(129.10767),  7.4590895]
        glob_vec = c.transform_vector_to_global(loc_vec, loc_pnt)
        glob_vec_ref = [1.,1.,1.]
        for c1, c2 in zip(glob_vec, glob_vec_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test multiple vectors, one ref point     
        loc_vecs = [[-0.2055972, -1.3184604, 1.1042608],
                       [0.43212494, -4.9808504, 5.0004397]]
        loc_pnt = [10.879429,   np.deg2rad(129.10767),  7.4590895]
        glob_vecs = [c.transform_vector_to_global(loc_vec, loc_pnt) for loc_vec in loc_vecs]
        glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]
        for v1, v2 in zip(glob_vecs, glob_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

        # test multiple vectors, multiple ref points
        
        loc_vecs = [[-0.2055972, -1.3184604, 1.1042608],
                    [0.43212494, -4.9808504, 5.0004397]]
        loc_pnts = [[10.879429, np.deg2rad(129.10767),  7.4590895], 
                     [10.879429,        np.deg2rad(129.10767),  7.4590895]]
        glob_vecs = [c.transform_vector_to_global(loc_vec, loc_pnt) 
                   for loc_vec, loc_pnt in zip(loc_vecs, loc_pnts)]
        glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]

        for v1, v2 in zip(glob_vecs, glob_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_other_from_rectangular_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_vecs = [[6, 7, 8],
                   [6, -7, 8]]

        c2_vecs_ref =  [[9.060223, 6.1417899, 5.4028489],
                        [2.1604354, -4.6338814, 11.084208]]
                    # calculated with ANSYS Workbench Mechanical

        c2_vecs = [c1.transform_vector_to_other(c2, c1_vec) for c1_vec in c1_vecs]
        
        for v1, v2 in zip(c2_vecs, c2_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_other_from_rectangular_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        ref_point = [-6.8625229, 8.4420236, 7.4590895]
        # ref point in c1 at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

        c1_vecs = [[6, 7, 8],
                   [6, -7, 8]]

        c2_vecs_ref =  [[5.5564038, -9.4305674, 5.4028489],
                        [-4.7612564, -1.8630018, 11.084208]]
                    # calculated with ANSYS Workbench Mechanical

        c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
        
        for v1, v2 in zip(c2_vecs, c2_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 6)

    def test_transform_vector_to_other_from_cylindrical_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        ref_point = [10.879429, np.deg2rad(129.10767),  7.4590895]
        # ref point in c1_cyl at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

        c1_vecs = [[6, 7, 8],
                   [6, -7, 8]]

        c2_vecs_ref =  [[-7.4896431, 7.9677196, 5.4240843],
                        [6.2996349, 9.7467169, 3.7836636]]
                    # calculated with ANSYS Workbench Mechanical

        c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
        
        for v1, v2 in zip(c2_vecs, c2_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 5)

    def test_transform_vector_to_other_from_cylindrical_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        ref_point = [10.879429, np.deg2rad(129.10767),  7.4590895]
        # ref point in c1_cyl at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

        c1_vecs = [[6, 7, 8],
                   [6, -7, 8]]

        c2_vecs_ref =  [[8.4255076, 6.9706622, 5.4240843],
                        [9.3287278, -6.9035301, 3.7836636]]
                    # calculated with ANSYS Workbench Mechanical

        c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
        
        for v1, v2 in zip(c2_vecs, c2_vecs_ref):
            for c1, c2 in zip(v1, v2):
                self.assertAlmostEqual(c1, c2, 5)

    def test_transform_tensor_from_global_into_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test as vector
        glob_tens = [0., -1., 0., 0., 0.,0.]
        loc_tens = c.transform_tensor_from_global(glob_tens)
        loc_tens_ref = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]

        for c1, c2 in zip(loc_tens, loc_tens_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test as matrix
        glob_tens = [[0, 0, 0],
                     [0,-1, 0],
                     [0, 0, 0]]
        loc_tens = c.transform_tensor_from_global(glob_tens)
        loc_tens_ref = [[-0.29575993, -0.44767285, 0.088741284],
                        [-0.44767285, -0.6776137,  0.134322],
                        [0.088741284,  0.134322,  -0.026626378]]
        
        for row, row_ref in zip(loc_tens, loc_tens_ref):
            for c1, c2 in zip(row, row_ref):
                self.assertAlmostEqual(c1, c2, 6) 

    def test_transform_tensor_from_global_into_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type= EOrientationSystems.CYLINDRICAL)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test as vector
        glob_tens = [0., -1., 0., 0., 0.,0.]
        ref_pnt = [30,30,30]
        loc_tens = c.transform_tensor_from_global(glob_tens, ref_pnt)
        loc_tens_ref = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]

        for c1, c2 in zip(loc_tens, loc_tens_ref):
            self.assertAlmostEqual(c1, c2, 6)

    def test_transform_tensor_to_global_from_rectangular(self):

        c = CoordinateSystem(&#39;C1&#39;)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test as vector
        glob_tens_ref = [0., -1., 0., 0., 0.,0.]
        loc_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]
        glob_tens = c.transform_tensor_to_global(loc_tens)
        

        for c1, c2 in zip(glob_tens, glob_tens_ref):
            self.assertAlmostEqual(c1, c2, 6)

        # test as matrix
        glob_tens_ref = [[0, 0, 0],
                        [0,-1, 0],
                        [0, 0, 0]]
        loc_tens = [[-0.29575993, -0.44767285, 0.088741284],
                        [-0.44767285, -0.6776137,  0.134322],
                        [0.088741284,  0.134322,  -0.026626378]]
        glob_tens = c.transform_tensor_to_global(loc_tens)
        
        for row, row_ref in zip(glob_tens, glob_tens_ref):
            for c1, c2 in zip(row, row_ref):
                self.assertAlmostEqual(c1, c2, 6) 

    def test_transform_tensor_to_global_from_cylindrical(self):

        c = CoordinateSystem(&#39;C1&#39;, type= EOrientationSystems.CYLINDRICAL)
        c.move([1., 2., -4.])
        c.rotate_x(10, degrees=True)
        c.rotate_y(20, degrees=True)
        c.rotate_z(30, degrees=True)
        # test as vector
        glob_tens_ref = [0., -1., 0., 0., 0.,0.]
        ref_pnt = [37.759005, 0.56643013, 36.813822]
        loc_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
        glob_tens = c.transform_tensor_to_global(loc_tens, ref_pnt)
        

        for c1, c2 in zip(glob_tens, glob_tens_ref):
            self.assertAlmostEqual(c1, c2, 6)

    def test_transform_tensor_to_other_from_rectangular_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]

        c2_tens_ref =  [-0.75690331, -9.6390665e-002, -0.14670602, -0.27010815, 0.11891632, 0.33323006]
                    # calculated with ANSYS Workbench Mechanical

        c2_tens = c1.transform_tensor_to_other(c2, c1_tens)
        
        for v1, v2 in zip(c2_tens, c2_tens_ref):
            self.assertAlmostEqual(v1, v2, 6)

    def test_transform_tensor_to_other_from_rectangular_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]
        ref_pnt = [31.86188, 20.262356, 36.813822]


        c2_tens_ref =  [-0.85213174, -1.1622426e-003, -0.14670602, 3.1470364e-002, -1.3057871e-002, 0.35357157]
                    # calculated with ANSYS Workbench Mechanical

        c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
        
        for v1, v2 in zip(c2_tens, c2_tens_ref):
            self.assertAlmostEqual(v1, v2, 6)

    def test_transform_tensor_to_other_from_cylindrical_to_rectangular(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
        ref_pnt = [37.759005, 0.56643013, 36.813822]
        c2_tens_ref =  [-0.75690331, -9.6390665e-002, -0.14670602, -0.27010815, 0.11891632, 0.33323006]
                    # calculated with ANSYS Workbench Mechanical

        c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
        
        for v1, v2 in zip(c2_tens, c2_tens_ref):
            self.assertAlmostEqual(v1, v2, 6)

    def test_transform_tensor_to_other_from_cylindrical_to_cylindrical(self):

        c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
        c1.move([1., 2., -4.])
        c1.rotate_x(10, degrees=True)
        c1.rotate_y(20, degrees=True)
        c1.rotate_z(30, degrees=True)

        c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
        c2.move([8., -3., 5.])
        c2.rotate_x(30, degrees=True)
        c2.rotate_y(40, degrees=True)
        c2.rotate_z(50, degrees=True)

        c1_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
        ref_pnt = [37.759005, 0.56643013, 36.813822]
        c2_tens_ref =  c2_tens_ref =  [-0.85213174, -1.1622426e-003, -0.14670602, 3.1470364e-002, -1.3057871e-002, 0.35357157]
                    # calculated with ANSYS Workbench Mechanical

        c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
        
        for v1, v2 in zip(c2_tens, c2_tens_ref):
            self.assertAlmostEqual(v1, v2, 6)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_default"><code class="name flex">
<span>def <span class="ident">test_default</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_default(self):
    c = CoordinateSystem(&#39;C1&#39;)
    known_mat = np.array([[1,0,0],[0,1,0],[0,0,1]], dtype=float)
    known_ori = np.zeros(3)
    self.assertTrue(np.allclose(known_mat, c.get_matrix()))
    self.assertTrue(np.allclose(known_ori, c.get_origin()))</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param"><code class="name flex">
<span>def <span class="ident">test_matrix_param</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_matrix_param(self):
    # tests also set_matrix(), because its called in __post_init__
    known_mat = np.array([[0,1,0],[-1,0,0],[0,0,1]], dtype=float)
    c = CoordinateSystem(&#39;C1&#39;, matrix=known_mat)
    self.assertTrue(np.allclose(known_mat, c.get_matrix()))</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param_not_all_rows_length_3"><code class="name flex">
<span>def <span class="ident">test_matrix_param_not_all_rows_length_3</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_matrix_param_not_all_rows_length_3(self):
    self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, matrix=[[1,0,0],[0,1,0],[0,0,1,0]])</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param_wrong_length"><code class="name flex">
<span>def <span class="ident">test_matrix_param_wrong_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_matrix_param_wrong_length(self):
    self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, matrix=[[1,0,0],[0,1,0],[0,0,1],[0,0,0]])</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_move"><code class="name flex">
<span>def <span class="ident">test_move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_move(self):
    c = CoordinateSystem(&#39;C1&#39;)
    c.move([1,2,3])
    self.assertTrue(np.allclose([1,2,3], c.get_origin()))
    c.move([1,2,3])
    self.assertTrue(np.allclose([2,4,6], c.get_origin()))</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_origin_param"><code class="name flex">
<span>def <span class="ident">test_origin_param</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_origin_param(self):
    # tests also set_origin(), because its called in __post_init__
    known_ori = np.array([2, 4, 6])
    c = CoordinateSystem(&#39;C1&#39;, origin=known_ori)
    self.assertTrue(np.allclose(known_ori, c.get_origin()))</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_origin_param_wrong_length"><code class="name flex">
<span>def <span class="ident">test_origin_param_wrong_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_origin_param_wrong_length(self):
    self.assertRaises(ValueError, CoordinateSystem, &#39;C1&#39;, origin=[2, 4, 6, 8])</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_rotate"><code class="name flex">
<span>def <span class="ident">test_rotate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_rotate(self):
    c = CoordinateSystem(&#39;C1&#39;)
    c.rotate_x(90, degrees=True)
    known_mat = np.array([[1, 0, 0],
                          [0, 0, 1],
                          [0, -1, 0]])
    self.assertTrue(np.allclose(known_mat, c.get_matrix()))

    c.rotate_y(90, degrees=True)
    known_mat = np.array([[0, 1, 0],
                          [0, 0, 1],
                          [1, 0, 0]])
    self.assertTrue(np.allclose(known_mat, c.get_matrix()))

    c.rotate_z(90, degrees=True)
    known_mat = np.array([[0, 0, 1],
                          [0, -1, 0],
                          [1, 0, 0]])
    self.assertTrue(np.allclose(known_mat, c.get_matrix()))</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_exception"><code class="name flex">
<span>def <span class="ident">test_transform_point_from_global_exception</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_from_global_exception(self):
    c = CoordinateSystem(&#39;C1&#39;)

    self.assertRaises(ValueError, c.transform_point_from_global, [0.])
    self.assertRaises(ValueError, c.transform_point_from_global, [0., 0.])
    self.assertRaises(ValueError, c.transform_point_from_global, [0., 0., 0., 0.])
    self.assertRaises(ValueError, c.transform_point_from_global, [[0., 0., 0.]])</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_into_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_point_from_global_into_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_from_global_into_cylindrical(self):

    c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)

    # test one point
    glob_pnt = np.array([-6,4,7], dtype=float)
    loc_pnt = c.transform_point_from_global(glob_pnt)
    loc_pnt_ref = np.array([7.2111026, np.deg2rad(146.30993), 7.])
                  # calculated with ANSYS Workbench Mechanical

    for c1, c2 in zip(loc_pnt, loc_pnt_ref):
        self.assertAlmostEqual(c1, c2, 7) #type: ignore

    # test multiple points
    glob_pnts = [[0,0,0],
                [1,1,1],
                [1,2,3],
                [-6,4,7]]
    
    loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]

    loc_pnts_ref =[[0.,     0.,     0.],
                    [1.4142136,     np.deg2rad(45.),        1.],
                    [2.236068,      np.deg2rad(63.434949),  3.],
                    [7.2111026,     np.deg2rad(146.30993),  7.]]
                # calculated with ANSYS Workbench Mechanical
    for p1, p2 in zip(loc_pnts, loc_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 6)

    # Test translated and rotated Cosy
    # ------------------------------------------------------------------
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]
    
    loc_pnts_ref =[[2.7227594,      np.deg2rad(177.92292),  3.685998],
                    [1.747404,      np.deg2rad(153.82496),  4.7902588],
                    [2.6526597,     np.deg2rad(122.72683),  6.477916],
                    [10.879429,     np.deg2rad(129.10767),  7.4590895]]
                   # calculated with ANSYS Workbench Mechanical

    for p1, p2 in zip(loc_pnts, loc_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_into_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_point_from_global_into_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_from_global_into_rectangular(self):

    # Test coincident cosy
    # ------------------------------------------------------------------
    # outpu must be input, because local and global system are coincident.
    c = CoordinateSystem(&#39;C1&#39;)

    # test one point
    glob_pnt = np.array([-6,4,7], dtype=float)
    loc_pnt = c.transform_point_from_global(glob_pnt)
    self.assertTrue(np.allclose(glob_pnt, loc_pnt))

    # Test translated and rotated Cosy
    # ------------------------------------------------------------------
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    glob_pnts = [[0,0,0],
                 [1,1,1],
                 [1,2,3],
                 [-6,4,7]]
    loc_pnts = [c.transform_point_from_global(glob_pnt) for glob_pnt in glob_pnts]
    loc_pnts_ref = [[-2.7209705, 9.8683531e-002, 3.685998],
                    [-1.5682088, 0.77080594, 4.7902588],
                    [-1.4341189, 2.2315704, 6.477916],
                    [-6.8625229, 8.4420236, 7.4590895]] 
                # calculated with ANSYS Workbench Mechanical
    
    for p1, p2 in zip(loc_pnts, loc_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 7)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_exception"><code class="name flex">
<span>def <span class="ident">test_transform_point_to_global_exception</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_to_global_exception(self):
    c = CoordinateSystem(&#39;C1&#39;)

    self.assertRaises(ValueError, c.transform_point_to_global, [0.])
    self.assertRaises(ValueError, c.transform_point_to_global, [0., 0.])
    self.assertRaises(ValueError, c.transform_point_to_global, [0., 0., 0., 0.])
    self.assertRaises(ValueError, c.transform_point_to_global, [[0., 0., 0.]])</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_from_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_point_to_global_from_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_to_global_from_cylindrical(self):

    c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)

    # test one point
    loc_pnt = [7.2111026, np.deg2rad(146.30993), 7.]
    # calculated with ANSYS Workbench Mechanical

    glob_pnt = c.transform_point_to_global(loc_pnt)
    glob_pnt_ref = np.array([-6,4,7], dtype=float)
                  
    for c1, c2 in zip(glob_pnt, glob_pnt_ref):
        self.assertAlmostEqual(c1, c2, 6) #type: ignore

    # test multiple points
    loc_pnts = [[0.,        0.,     0.],
                [1.4142136, np.deg2rad(45.),        1.],
                [2.236068,  np.deg2rad(63.434949),  3.],
                [7.2111026, np.deg2rad(146.30993),  7.]]
                # calculated with ANSYS Workbench Mechanical
    
    glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

    glob_pnts_ref = [[ 0., 0., 0.],
                    [ 1., 1., 1.],
                    [ 1., 2., 3.],
                    [-6., 4., 7.]]

    for p1, p2 in zip(glob_pnts, glob_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 6)

    # Test translated and rotated Cosy
    # ------------------------------------------------------------------
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)

    loc_pnts = [[2.7227594, np.deg2rad(177.92292),  3.685998],
                [1.747404,  np.deg2rad(153.82496),  4.7902588],
                [2.6526597, np.deg2rad(122.72683),  6.477916],
                [10.879429, np.deg2rad(129.10767),  7.4590895]] 
                # calculated with ANSYS Workbench Mechanical
    
    glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

    for p1, p2 in zip(glob_pnts, glob_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_from_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_point_to_global_from_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_to_global_from_rectangular(self):

    c = CoordinateSystem(&#39;C1&#39;)

    # test one point
    loc_pnt = np.array([-6,4,7], dtype=float)
    glob_pnt = c.transform_point_to_global(loc_pnt)
    self.assertTrue(np.allclose(glob_pnt, loc_pnt))

    # test multiple points
    loc_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                [-1.5682088, 0.77080594,   4.7902588],
                [-1.4341189, 2.23157040,   6.477916],
                [-6.8625229, 8.44202360,   7.4590895]]
                # calculated with ANSYS Workbench Mechanical
    
    glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]

    self.assertTrue(np.allclose(glob_pnts, loc_pnts))

    # Test translated and rotated Cosy
    # ------------------------------------------------------------------
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    glob_pnts = [c.transform_point_to_global(loc_pnt) for loc_pnt in loc_pnts]
    glob_pnts_ref = [[ 0., 0., 0.],
                    [ 1., 1., 1.],
                    [ 1., 2., 3.],
                    [-6., 4., 7.]] 
                # calculated with ANSYS Workbench Mechanical
    
    for p1, p2 in zip(glob_pnts, glob_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_cylindrical_to_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_point_to_other_from_cylindrical_to_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_to_other_from_cylindrical_to_cylindrical(self):

    c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_pnts = [[2.7227594,  np.deg2rad(177.92292),  3.685998],
                [1.747404, np.deg2rad(153.82496),   4.7902588],
                [2.6526597, np.deg2rad(122.72683),  6.477916],
                [10.879429, np.deg2rad(129.10767),  7.4590895]]
                # calculated with ANSYS Workbench Mechanical

    c2_pnts_ref = [[2.3828414,      np.deg2rad(127.64108),  -9.6084373],
                    [2.3592996,     np.deg2rad(91.642505),  -8.6852579],
                    [4.2508725,     np.deg2rad(78.427201),  -7.7414523],
                    [11.908319,     np.deg2rad(93.626557),  -10.353354]]
                # calculated with ANSYS Workbench Mechanical

    c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
    
    for p1, p2 in zip(c2_pnts, c2_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 5)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_cylindrical_to_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_point_to_other_from_cylindrical_to_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_to_other_from_cylindrical_to_rectangular(self):

    c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_pnts = [[2.7227594,  np.deg2rad(177.92292),  3.685998],
                [1.747404, np.deg2rad(153.82496),   4.7902588],
                [2.6526597, np.deg2rad(122.72683),  6.477916],
                [10.879429, np.deg2rad(129.10767),  7.4590895]]
                # calculated with ANSYS Workbench Mechanical

    c2_pnts_ref =  [[-1.4552322,    1.8868577, -9.6084373],
                    [-6.7625066e-2, 2.3583302, -8.6852579],
                    [ 0.85277961,   4.1644548, -7.7414523],
                    [-0.75323817,  11.884473, -10.353354]]
                # calculated with ANSYS Workbench Mechanical

    c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
    
    for p1, p2 in zip(c2_pnts, c2_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 5)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_rectangular_to_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_point_to_other_from_rectangular_to_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_to_other_from_rectangular_to_cylindrical(self):

    c1 = CoordinateSystem(&#39;C1&#39;)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                [-1.5682088, 0.77080594,   4.7902588],
                [-1.4341189, 2.23157040,   6.477916],
                [-6.8625229, 8.44202360,   7.4590895]]
                # calculated with ANSYS Workbench Mechanical

    c2_pnts_ref = [[2.3828414,      np.deg2rad(127.64108),  -9.6084373],
                    [2.3592996,     np.deg2rad(91.642505),  -8.6852579],
                    [4.2508725,     np.deg2rad(78.427201),  -7.7414523],
                    [11.908319,     np.deg2rad(93.626557),  -10.353354]]
                # calculated with ANSYS Workbench Mechanical

    c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
    
    for p1, p2 in zip(c2_pnts, c2_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_rectangular_to_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_point_to_other_from_rectangular_to_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_point_to_other_from_rectangular_to_rectangular(self):

    c1 = CoordinateSystem(&#39;C1&#39;)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_pnts = [[-2.7209705, 9.8683531e-2, 3.685998],
                [-1.5682088, 0.77080594,   4.7902588],
                [-1.4341189, 2.23157040,   6.477916],
                [-6.8625229, 8.44202360,   7.4590895]]
                # calculated with ANSYS Workbench Mechanical

    c2_pnts_ref =  [[-1.4552322,    1.8868577, -9.6084373],
                    [-6.7625066e-2, 2.3583302, -8.6852579],
                    [ 0.85277961,   4.1644548, -7.7414523],
                    [-0.75323817,  11.884473, -10.353354]]
                # calculated with ANSYS Workbench Mechanical

    c2_pnts = [c1.transform_point_to_other(c1_pnt, c2) for c1_pnt in c1_pnts]
    
    for p1, p2 in zip(c2_pnts, c2_pnts_ref):
        for c1, c2 in zip(p1, p2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_from_global_into_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_tensor_from_global_into_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_tensor_from_global_into_cylindrical(self):

    c = CoordinateSystem(&#39;C1&#39;, type= EOrientationSystems.CYLINDRICAL)
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    # test as vector
    glob_tens = [0., -1., 0., 0., 0.,0.]
    ref_pnt = [30,30,30]
    loc_tens = c.transform_tensor_from_global(glob_tens, ref_pnt)
    loc_tens_ref = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]

    for c1, c2 in zip(loc_tens, loc_tens_ref):
        self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_from_global_into_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_tensor_from_global_into_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_tensor_from_global_into_rectangular(self):

    c = CoordinateSystem(&#39;C1&#39;)
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    # test as vector
    glob_tens = [0., -1., 0., 0., 0.,0.]
    loc_tens = c.transform_tensor_from_global(glob_tens)
    loc_tens_ref = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]

    for c1, c2 in zip(loc_tens, loc_tens_ref):
        self.assertAlmostEqual(c1, c2, 6)

    # test as matrix
    glob_tens = [[0, 0, 0],
                 [0,-1, 0],
                 [0, 0, 0]]
    loc_tens = c.transform_tensor_from_global(glob_tens)
    loc_tens_ref = [[-0.29575993, -0.44767285, 0.088741284],
                    [-0.44767285, -0.6776137,  0.134322],
                    [0.088741284,  0.134322,  -0.026626378]]
    
    for row, row_ref in zip(loc_tens, loc_tens_ref):
        for c1, c2 in zip(row, row_ref):
            self.assertAlmostEqual(c1, c2, 6) </code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_global_from_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_tensor_to_global_from_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_tensor_to_global_from_cylindrical(self):

    c = CoordinateSystem(&#39;C1&#39;, type= EOrientationSystems.CYLINDRICAL)
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    # test as vector
    glob_tens_ref = [0., -1., 0., 0., 0.,0.]
    ref_pnt = [37.759005, 0.56643013, 36.813822]
    loc_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
    glob_tens = c.transform_tensor_to_global(loc_tens, ref_pnt)
    

    for c1, c2 in zip(glob_tens, glob_tens_ref):
        self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_global_from_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_tensor_to_global_from_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_tensor_to_global_from_rectangular(self):

    c = CoordinateSystem(&#39;C1&#39;)
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    # test as vector
    glob_tens_ref = [0., -1., 0., 0., 0.,0.]
    loc_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]
    glob_tens = c.transform_tensor_to_global(loc_tens)
    

    for c1, c2 in zip(glob_tens, glob_tens_ref):
        self.assertAlmostEqual(c1, c2, 6)

    # test as matrix
    glob_tens_ref = [[0, 0, 0],
                    [0,-1, 0],
                    [0, 0, 0]]
    loc_tens = [[-0.29575993, -0.44767285, 0.088741284],
                    [-0.44767285, -0.6776137,  0.134322],
                    [0.088741284,  0.134322,  -0.026626378]]
    glob_tens = c.transform_tensor_to_global(loc_tens)
    
    for row, row_ref in zip(glob_tens, glob_tens_ref):
        for c1, c2 in zip(row, row_ref):
            self.assertAlmostEqual(c1, c2, 6) </code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_cylindrical_to_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_tensor_to_other_from_cylindrical_to_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_tensor_to_other_from_cylindrical_to_cylindrical(self):

    c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
    ref_pnt = [37.759005, 0.56643013, 36.813822]
    c2_tens_ref =  c2_tens_ref =  [-0.85213174, -1.1622426e-003, -0.14670602, 3.1470364e-002, -1.3057871e-002, 0.35357157]
                # calculated with ANSYS Workbench Mechanical

    c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
    
    for v1, v2 in zip(c2_tens, c2_tens_ref):
        self.assertAlmostEqual(v1, v2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_cylindrical_to_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_tensor_to_other_from_cylindrical_to_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_tensor_to_other_from_cylindrical_to_rectangular(self):

    c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_tens = [-0.81114565, -0.16222797, -2.6626378e-002, -0.36275406, 6.5723232e-002, 0.14696214]
    ref_pnt = [37.759005, 0.56643013, 36.813822]
    c2_tens_ref =  [-0.75690331, -9.6390665e-002, -0.14670602, -0.27010815, 0.11891632, 0.33323006]
                # calculated with ANSYS Workbench Mechanical

    c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
    
    for v1, v2 in zip(c2_tens, c2_tens_ref):
        self.assertAlmostEqual(v1, v2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_rectangular_to_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_tensor_to_other_from_rectangular_to_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_tensor_to_other_from_rectangular_to_cylindrical(self):

    c1 = CoordinateSystem(&#39;C1&#39;)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]
    ref_pnt = [31.86188, 20.262356, 36.813822]


    c2_tens_ref =  [-0.85213174, -1.1622426e-003, -0.14670602, 3.1470364e-002, -1.3057871e-002, 0.35357157]
                # calculated with ANSYS Workbench Mechanical

    c2_tens = c1.transform_tensor_to_other(c2, c1_tens, ref_pnt)
    
    for v1, v2 in zip(c2_tens, c2_tens_ref):
        self.assertAlmostEqual(v1, v2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_rectangular_to_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_tensor_to_other_from_rectangular_to_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_tensor_to_other_from_rectangular_to_rectangular(self):

    c1 = CoordinateSystem(&#39;C1&#39;)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_tens = [-0.29575993, -0.6776137, -2.6626378e-002, -0.44767285, 0.134322, 8.8741284e-002]

    c2_tens_ref =  [-0.75690331, -9.6390665e-002, -0.14670602, -0.27010815, 0.11891632, 0.33323006]
                # calculated with ANSYS Workbench Mechanical

    c2_tens = c1.transform_tensor_to_other(c2, c1_tens)
    
    for v1, v2 in zip(c2_tens, c2_tens_ref):
        self.assertAlmostEqual(v1, v2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_from_global_into_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_vector_from_global_into_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_vector_from_global_into_cylindrical(self):

    c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    # test one vector, one ref point
    glob_vec = [1.,1.,1.]
    glob_pnt = [-6.,4.,7.]
    loc_vec = c.transform_vector_from_global(glob_vec, glob_pnt)
    loc_vec_ref = [-0.2055972, -1.3184604, 1.1042608]

    for c1, c2 in zip(loc_vec, loc_vec_ref):
        self.assertAlmostEqual(c1, c2, 6)

    # test multiple vectors, one ref point
    glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
    glob_pnt = [-6.,4.,7.]
    loc_vec = [c.transform_vector_from_global(glob_vec, glob_pnt) for glob_vec in glob_vecs]
    loc_vec_ref = [[-0.2055972, -1.3184604, 1.1042608],
                   [0.43212494, -4.9808504, 5.0004397]]
    for v1, v2 in zip(loc_vec, loc_vec_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 6)

    # test multiple vectors, multiple ref points
    glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
    glob_pnts = [[-6.,4.,7.], [-6.,4.,7.]]
    loc_vec = [c.transform_vector_from_global(glob_vec, glob_pnt) 
               for glob_vec, glob_pnt in zip(glob_vecs, glob_pnts)]
    
    loc_vec_ref = [[-0.2055972, -1.3184604, 1.1042608],
                   [0.43212494, -4.9808504, 5.0004397]]
    for v1, v2 in zip(loc_vec, loc_vec_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_from_global_into_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_vector_from_global_into_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_vector_from_global_into_rectangular(self):

    c = CoordinateSystem(&#39;C1&#39;)
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    # test one point
    glob_vec = [1.,1.,1.]
    loc_vec = c.transform_vector_from_global(glob_vec)
    loc_vec_ref = [1.1527617, 0.67212241, 1.1042608]

    for c1, c2 in zip(loc_vec, loc_vec_ref):
        self.assertAlmostEqual(c1, c2, 6)

    # # test multiple points
    glob_vecs = [[1.,1.,1.],[3.,4.,5.]]
    loc_vec = [c.transform_vector_from_global(glob_vec) for glob_vec in glob_vecs]
    loc_vec_ref = [[1.1527617, 0.67212241, 1.1042608],
                   [3.592375, 3.4771317, 5.0004397]]
    for v1, v2 in zip(loc_vec, loc_vec_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_global_from_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_vector_to_global_from_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_vector_to_global_from_cylindrical(self):

    c = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    # test one vector, one ref point
    loc_vec = [-0.2055972, -1.3184604, 1.1042608]
    loc_pnt = [10.879429,   np.deg2rad(129.10767),  7.4590895]
    glob_vec = c.transform_vector_to_global(loc_vec, loc_pnt)
    glob_vec_ref = [1.,1.,1.]
    for c1, c2 in zip(glob_vec, glob_vec_ref):
        self.assertAlmostEqual(c1, c2, 6)

    # test multiple vectors, one ref point     
    loc_vecs = [[-0.2055972, -1.3184604, 1.1042608],
                   [0.43212494, -4.9808504, 5.0004397]]
    loc_pnt = [10.879429,   np.deg2rad(129.10767),  7.4590895]
    glob_vecs = [c.transform_vector_to_global(loc_vec, loc_pnt) for loc_vec in loc_vecs]
    glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]
    for v1, v2 in zip(glob_vecs, glob_vecs_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 6)

    # test multiple vectors, multiple ref points
    
    loc_vecs = [[-0.2055972, -1.3184604, 1.1042608],
                [0.43212494, -4.9808504, 5.0004397]]
    loc_pnts = [[10.879429, np.deg2rad(129.10767),  7.4590895], 
                 [10.879429,        np.deg2rad(129.10767),  7.4590895]]
    glob_vecs = [c.transform_vector_to_global(loc_vec, loc_pnt) 
               for loc_vec, loc_pnt in zip(loc_vecs, loc_pnts)]
    glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]

    for v1, v2 in zip(glob_vecs, glob_vecs_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_global_from_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_vector_to_global_from_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_vector_to_global_from_rectangular(self):

    c = CoordinateSystem(&#39;C1&#39;)
    c.move([1., 2., -4.])
    c.rotate_x(10, degrees=True)
    c.rotate_y(20, degrees=True)
    c.rotate_z(30, degrees=True)
    # test one point
    loc_vec = [1.1527617, 0.67212241, 1.1042608]
    glob_vec = c.transform_vector_to_global(loc_vec)
    glob_vec_ref = [1.,1.,1.]
    
    for c1, c2 in zip(glob_vec, glob_vec_ref):
        self.assertAlmostEqual(c1, c2, 6)

    # test multiple points
    loc_vecs = [[1.1527617, 0.67212241, 1.1042608],
                   [3.592375, 3.4771317, 5.0004397]]
    glob_vecs = [c.transform_vector_to_global(loc_vec) for loc_vec in loc_vecs]
    glob_vecs_ref = [[1.,1.,1.],[3.,4.,5.]]

    for v1, v2 in zip(glob_vecs, glob_vecs_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_cylindrical_to_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_vector_to_other_from_cylindrical_to_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_vector_to_other_from_cylindrical_to_cylindrical(self):

    c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    ref_point = [10.879429, np.deg2rad(129.10767),  7.4590895]
    # ref point in c1_cyl at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

    c1_vecs = [[6, 7, 8],
               [6, -7, 8]]

    c2_vecs_ref =  [[8.4255076, 6.9706622, 5.4240843],
                    [9.3287278, -6.9035301, 3.7836636]]
                # calculated with ANSYS Workbench Mechanical

    c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
    
    for v1, v2 in zip(c2_vecs, c2_vecs_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 5)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_cylindrical_to_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_vector_to_other_from_cylindrical_to_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_vector_to_other_from_cylindrical_to_rectangular(self):

    c1 = CoordinateSystem(&#39;C1&#39;, type=EOrientationSystems.CYLINDRICAL)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    ref_point = [10.879429, np.deg2rad(129.10767),  7.4590895]
    # ref point in c1_cyl at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

    c1_vecs = [[6, 7, 8],
               [6, -7, 8]]

    c2_vecs_ref =  [[-7.4896431, 7.9677196, 5.4240843],
                    [6.2996349, 9.7467169, 3.7836636]]
                # calculated with ANSYS Workbench Mechanical

    c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
    
    for v1, v2 in zip(c2_vecs, c2_vecs_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 5)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_rectangular_to_cylindrical"><code class="name flex">
<span>def <span class="ident">test_transform_vector_to_other_from_rectangular_to_cylindrical</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_vector_to_other_from_rectangular_to_cylindrical(self):

    c1 = CoordinateSystem(&#39;C1&#39;)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;, type=EOrientationSystems.CYLINDRICAL)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    ref_point = [-6.8625229, 8.4420236, 7.4590895]
    # ref point in c1 at global [-6, 4, 7]. Transformed with ANSYS Workbench Mechanical

    c1_vecs = [[6, 7, 8],
               [6, -7, 8]]

    c2_vecs_ref =  [[5.5564038, -9.4305674, 5.4028489],
                    [-4.7612564, -1.8630018, 11.084208]]
                # calculated with ANSYS Workbench Mechanical

    c2_vecs = [c1.transform_vector_to_other(c2, c1_vec, ref_point) for c1_vec in c1_vecs]
    
    for v1, v2 in zip(c2_vecs, c2_vecs_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
<dt id="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_rectangular_to_rectangular"><code class="name flex">
<span>def <span class="ident">test_transform_vector_to_other_from_rectangular_to_rectangular</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_transform_vector_to_other_from_rectangular_to_rectangular(self):

    c1 = CoordinateSystem(&#39;C1&#39;)
    c1.move([1., 2., -4.])
    c1.rotate_x(10, degrees=True)
    c1.rotate_y(20, degrees=True)
    c1.rotate_z(30, degrees=True)

    c2 = CoordinateSystem(&#39;C2&#39;)
    c2.move([8., -3., 5.])
    c2.rotate_x(30, degrees=True)
    c2.rotate_y(40, degrees=True)
    c2.rotate_z(50, degrees=True)

    c1_vecs = [[6, 7, 8],
               [6, -7, 8]]

    c2_vecs_ref =  [[9.060223, 6.1417899, 5.4028489],
                    [2.1604354, -4.6338814, 11.084208]]
                # calculated with ANSYS Workbench Mechanical

    c2_vecs = [c1.transform_vector_to_other(c2, c1_vec) for c1_vec in c1_vecs]
    
    for v1, v2 in zip(c2_vecs, c2_vecs_ref):
        for c1, c2 in zip(v1, v2):
            self.assertAlmostEqual(c1, c2, 6)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pygccx.helper_features.test" href="index.html">pygccx.helper_features.test</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem">TestCoordinateSystem</a></code></h4>
<ul class="">
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_default" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_default">test_default</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param">test_matrix_param</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param_not_all_rows_length_3" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param_not_all_rows_length_3">test_matrix_param_not_all_rows_length_3</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param_wrong_length" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_matrix_param_wrong_length">test_matrix_param_wrong_length</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_move" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_move">test_move</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_origin_param" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_origin_param">test_origin_param</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_origin_param_wrong_length" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_origin_param_wrong_length">test_origin_param_wrong_length</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_rotate" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_rotate">test_rotate</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_exception" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_exception">test_transform_point_from_global_exception</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_into_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_into_cylindrical">test_transform_point_from_global_into_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_into_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_from_global_into_rectangular">test_transform_point_from_global_into_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_exception" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_exception">test_transform_point_to_global_exception</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_from_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_from_cylindrical">test_transform_point_to_global_from_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_from_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_global_from_rectangular">test_transform_point_to_global_from_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_cylindrical_to_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_cylindrical_to_cylindrical">test_transform_point_to_other_from_cylindrical_to_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_cylindrical_to_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_cylindrical_to_rectangular">test_transform_point_to_other_from_cylindrical_to_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_rectangular_to_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_rectangular_to_cylindrical">test_transform_point_to_other_from_rectangular_to_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_rectangular_to_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_point_to_other_from_rectangular_to_rectangular">test_transform_point_to_other_from_rectangular_to_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_from_global_into_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_from_global_into_cylindrical">test_transform_tensor_from_global_into_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_from_global_into_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_from_global_into_rectangular">test_transform_tensor_from_global_into_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_global_from_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_global_from_cylindrical">test_transform_tensor_to_global_from_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_global_from_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_global_from_rectangular">test_transform_tensor_to_global_from_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_cylindrical_to_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_cylindrical_to_cylindrical">test_transform_tensor_to_other_from_cylindrical_to_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_cylindrical_to_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_cylindrical_to_rectangular">test_transform_tensor_to_other_from_cylindrical_to_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_rectangular_to_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_rectangular_to_cylindrical">test_transform_tensor_to_other_from_rectangular_to_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_rectangular_to_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_tensor_to_other_from_rectangular_to_rectangular">test_transform_tensor_to_other_from_rectangular_to_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_from_global_into_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_from_global_into_cylindrical">test_transform_vector_from_global_into_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_from_global_into_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_from_global_into_rectangular">test_transform_vector_from_global_into_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_global_from_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_global_from_cylindrical">test_transform_vector_to_global_from_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_global_from_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_global_from_rectangular">test_transform_vector_to_global_from_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_cylindrical_to_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_cylindrical_to_cylindrical">test_transform_vector_to_other_from_cylindrical_to_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_cylindrical_to_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_cylindrical_to_rectangular">test_transform_vector_to_other_from_cylindrical_to_rectangular</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_rectangular_to_cylindrical" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_rectangular_to_cylindrical">test_transform_vector_to_other_from_rectangular_to_cylindrical</a></code></li>
<li><code><a title="pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_rectangular_to_rectangular" href="#pygccx.helper_features.test.test_coordinate_system.TestCoordinateSystem.test_transform_vector_to_other_from_rectangular_to_rectangular">test_transform_vector_to_other_from_rectangular_to_rectangular</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>